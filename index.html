  <!-- Welcome Popup (Tailwind) -->
  <div id="welcome-popup" class="fixed inset-0 z-50 flex items-center justify-center bg-black/20">
    <div class="bg-white/80 backdrop-blur-md max-w-2xl w-full p-6 rounded-xl shadow-2xl relative text-slate-800 overflow-auto max-h-screen text-xxs">
      <button id="welcome-close" aria-label="Close welcome popup" class="btn-tertiary w-8 h-8 p-0 absolute top-3 right-3">&times;</button>
      <h2 class="text-md font-semibold mb-3 text-primary">Glacial Lakes: A Rapid Survey Mission</h2>
      <p class="text-xxs mb-3"><strong>A Project to Protect Communities in the Nepal Himalaya</strong></p>
      <p class="text-xxs mb-3">In 2019, I joined a small team of experts as a project coordinator and drone pilot on a rapid mission to photograph four potentially dangerous glacial lakes in the Nepal Himalaya. Using an innovative approach, we mounted a drone inside a rescue helicopter and flew above 4,500–5,000 meters to capture the rocky dams that hold these lakes in place. We were able to reduce around 3 months of survey work to just 4 days.</p>
      
      <h3 class="font-semibold text-xs mt-3 mb-2">The Mission in the Sky</h3>
      <p class="text-xxs mb-3">For the actual survey, only the helicopter pilot and I stayed onboard. I sat with the drone controller while she flew through narrow valleys and strong winds. I gave voice commands like "left a little," "hold this line" while monitoring the controller and GPS tracks. The drone captured a photo every two seconds through the transparent window at the bottom. The turbulence was intense at times, but we managed to cover the full end-moraines, which was the most important part of the mission.</p>
      
      <h3 class="font-semibold text-xs mt-3 mb-2">Why We Mounted the Drone Inside the Helicopter</h3>
      <ul class="list-disc pl-5 text-xxs space-y-1 mb-3">
        <li>Reaching a single lake on foot would take around 7+ days</li>
        <li>High altitude (4,500–5,200m) meant the helicopter had to stay light and fast, with areas having no safe landing spots</li>
        <li>Weather changes very quickly at this altitude, giving us only a short morning window</li>
        <li>Some lakes were too windy or steep for safe drone takeoff/landing from the ground</li>
      </ul>
      
      <h3 class="font-semibold text-xs mt-3 mb-2">Impact & Results</h3>
      <p class="text-xxs mb-3">The images from this photogrammetric survey were processed into detailed topographic models, giving civil engineers the data they needed to design practical interventions to lower each lake to a safer level. These results were later used in a proposal to the Green Climate Fund (GCF), prepared jointly by UNDP and the Department of Hydrology and Meteorology (DHM). The proposal secured USD 36.1 million for lake-lowering and downstream safety interventions, with funding officially approved in 2025. Once completed, this work is expected to help protect thousands of lives and livelihoods in communities living downstream.</p>
        <div class="flex justify-end gap-3">
        <button id="welcome-skip" class="btn-tertiary text-xs">Skip</button>
        <button id="welcome-no-show" class="btn-primary text-xs">Don't show again</button>
      </div>
    </div>
  </div>
  </div>
  <script>
    // Welcome popup logic — do not auto-hide on load (user requested persistent welcome)
    window.addEventListener('DOMContentLoaded', function() {
      var popup = document.getElementById('welcome-popup');
      var closeBtn = document.getElementById('welcome-close');
      var skipBtn = document.getElementById('welcome-skip');
      var noShowBtn = document.getElementById('welcome-no-show');

      if (popup) {
        if (closeBtn) {
          closeBtn.addEventListener('click', function() { popup.classList.add('hidden'); });
        }
        if (skipBtn) {
          skipBtn.addEventListener('click', function() { popup.classList.add('hidden'); });
        }
        if (noShowBtn) {
          noShowBtn.addEventListener('click', function() {
            try { localStorage.setItem('welcome_dont_show', '1'); } catch (e) {}
            popup.classList.add('hidden');
          });
        }
      }
    });
  </script>
<html class="h-full">
<head>
  <meta charset="utf-8" />
  <title>Glacial Lakes</title>
  <link
    href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css"
    rel="stylesheet"
  />
  <!-- Tailwind CSS (CDN for rapid prototyping) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Tailwind config: project palette and Inter font (b1) -->
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: '#2A77ED',
            secondary: '#EDA02A',
            tertiary: '#ED2AD8',
            accent: '#16a085'
          },
          fontFamily: {
            sans: ['Inter', 'system-ui', '-apple-system', 'Segoe UI', 'Roboto', 'Helvetica Neue', 'Arial']
          }
        }
      }
    };
  </script>
  <style>
    /* Lightweight button styles so we don't need @apply or runtime mapping.
       Keeps styles local and simple; colors match the Tailwind config tokens. */
    .btn-primary {
      display: inline-flex; align-items: center; gap: 0.5rem;
      padding: 0.25rem 0.75rem; border-radius: 0.375rem; font-size: 0.875rem;
      background: #2A77ED; color: #ffffff; border: 1px solid rgba(0,0,0,0.05);
      cursor: pointer;
    }
    .btn-primary:hover { opacity: 0.92; }
    .btn-primary:disabled { opacity: 0.6; cursor: not-allowed; }

    .btn-secondary {
      display: inline-flex; align-items: center; gap: 0.5rem;
      padding: 0.25rem 0.75rem; border-radius: 0.375rem; font-size: 0.875rem;
      background: #EDA02A; color: #ffffff; border: 1px solid rgba(0,0,0,0.05);
      cursor: pointer;
    }
    .btn-secondary:hover { opacity: 0.92; }
    .btn-secondary:disabled { opacity: 0.6; cursor: not-allowed; }

    .btn-accent {
      display: inline-flex; align-items: center; gap: 0.5rem;
      padding: 0.25rem 0.75rem; border-radius: 0.375rem; font-size: 0.875rem;
      background: #16a085; color: #ffffff; border: 1px solid rgba(0,0,0,0.05);
      cursor: pointer;
    }
    .btn-accent:hover { opacity: 0.92; }
    .btn-accent:disabled { opacity: 0.6; cursor: not-allowed; }

    .btn-tertiary {
      display: inline-flex; align-items: center; gap: 0.5rem;
      padding: 0.25rem 0.75rem; border-radius: 0.375rem; font-size: 0.875rem;
      background: transparent; color: #334155; border: 1px solid #f1f5f9;
      cursor: pointer;
    }
    .btn-tertiary:hover { background: #f8fafc; }
    .btn-tertiary:disabled { opacity: 0.6; cursor: not-allowed; }

    /* Small utility helpers used by JS for compact icon buttons */
    .icon-btn { display:inline-flex; align-items:center; justify-content:center; min-width:2rem; height:2rem; padding:1rem; border-radius:0.375rem; }
     /* Switch styles: small/xs/md sizes and checked state handling
       Use CSS variables to make knob positioning precise and consistent across sizes.
       Markup pattern used in the UI:
       <label class="switch switch-sm"><input type="checkbox" class="sr-only" /><div class="switch-track"><div class="switch-knob"></div></div></label>
    */
    .switch {
      --switch-track-width: 42px;
      --switch-track-height: 22px;
      --switch-knob-size: 14px;
      --switch-padding: 4px; /* distance from left edge */
      display: inline-flex;
      align-items: center;
      cursor: pointer;
      position: relative;
    }
    .switch .switch-track {
      position: relative;
      background: #d9d9d9 !important; /* neutral gray when off - force override */
      border-radius: 9999px;
      transition: background .15s ease;
      width: var(--switch-track-width);
      height: var(--switch-track-height);
    }
    .switch .switch-knob {
      position: absolute;
      top: 50%;
      left: var(--switch-padding);
      transform: translateY(-50%);
      width: var(--switch-knob-size);
      height: var(--switch-knob-size);
      background: #D6D9DE !important; /* adjusted gray-200 (darker for visibility) */
      border: 1px solid rgba(15,23,42,0.08) !important; /* stronger subtle border */
      border-radius: 9999px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.08) !important;
      transition: left .15s ease, transform .15s ease, background .1s ease;
      box-sizing: border-box;
    }
    /* size presets */
    .switch-xxs { --switch-track-width: 26px; --switch-track-height: 14px; --switch-knob-size: 10px; --switch-padding: 2px; }
    .switch-xs { --switch-track-width: 34px; --switch-track-height: 18px; --switch-knob-size: 12px; --switch-padding: 3px; }
    .switch-sm { --switch-track-width: 42px; --switch-track-height: 22px; --switch-knob-size: 14px; --switch-padding: 4px; }
    .switch-md { --switch-track-width: 56px; --switch-track-height: 28px; --switch-knob-size: 18px; --switch-padding: 5px; }
    /* hide the native checkbox but keep it in the DOM order for + selector */
    .switch input[type="checkbox"] { position: absolute; opacity: 0; pointer-events: none; width: 0; height: 0; }
    /* checked state: move knob precisely accounting for knob size + padding (visual color enforced by specific selector below) */
    .switch input[type="checkbox"]:checked + .switch-track .switch-knob { left: calc(100% - var(--switch-knob-size) - var(--switch-padding)); background: #ffffff !important; border-color: rgba(0,0,0,0.06) !important; box-shadow: 0 1px 3px rgba(0,0,0,0.12) !important; }
    /* Compatibility for older markup patterns where .relative wrapper is used */
    label input[type="checkbox"]:checked + .relative .switch-bg { background: #2A77ED !important; }
    label input[type="checkbox"]:checked + .relative .switch-knob { transform: translateX(1.5rem) !important; }
     /* Ensure the off-state track is visible even if other styles try to override it.
       Use more specific selectors and cover pseudo-elements; also clear background-image
       so gradients or other utilities don't mask the color. */
      /* Limit enforced track background rules to the layer panel only to avoid
        duplicating the general .switch definition above. */
      #layer-panel .switch .switch-track,
      #layer-panel .switch .switch-track::before,
      #layer-panel .switch .switch-track::after {
      background: #d9d9d9 !important;
      background-color: #d9d9d9 !important;
      background-image: none !important;
      }
    #layer-panel{
      height: 95vh;
    }
    /* Explicit input+track selectors with highest local specificity to enforce states
       without JS. These should win over generic utility classes from Tailwind. */
    #layer-panel .switch input[type="checkbox"] + .switch-track { background: #d9d9d9 !important; background-image: none !important; }
    /* Keep the color-binding rule only inside #layer-panel (higher specificity). */
    #layer-panel .switch input[type="checkbox"]:checked + .switch-track { background: #2A77ED !important; background-image: none !important; }
    label input[type="checkbox"] + .relative .switch-bg { background: #d9d9d9 !important; background-image: none !important; }

     /* Welcome popup overlay: ensure a semi-opaque dark veil behind the modal so it stands out
       (some utility classes can make it appear fully transparent depending on cascade; enforce here).
       Also ensure the modal sits above other fixed UI elements (scalebar, controls) by increasing z-index. */
     #welcome-popup { background-color: rgba(0,0,0,0.45) !important; backdrop-filter: none !important; z-index: 9999 !important; position: fixed !important; }
     
     .rounded-lg-top {
        border-top-left-radius: 0.5rem;
        border-top-right-radius: 0.5rem;
     }
     
     /* Glacier navigation button styling */
     .glacier-nav-btn {
       font-size: 0.75rem;
       padding: 0.5rem 0.75rem;
       border-radius: 0.375rem;
       cursor: pointer;
       transition: all 0.2s ease;
     }
     .glacier-nav-btn:hover {
       opacity: 0.9;
       transform: translateY(-2px);
     }
  </style>
  <style>
    /* Override MapLibre's ctrl button background so our Tailwind utility colors show */
    .maplibregl-ctrl-group button.bg-primary { background-color: #2A77ED !important; color: #fff !important; }
    .maplibregl-ctrl-group button.bg-secondary { background-color: #EDA02A !important; color: #fff !important; }
    .maplibregl-ctrl-group button.bg-tertiary { background-color: #ED2AD8 !important; color: #fff !important; }
    /* Ensure control container doesn't clip absolute children and buttons */
    .map-control-container { overflow: visible !important; }
    .maplibregl-ctrl-group button { overflow: visible !important; min-width:auto;}
    .maplibregl-popup-close-button{padding-right: 3px;}

    /* Provide a few utility classes that our JS toggles — keep them small and explicit so they work without JIT
       These mirror the Tailwind utilities used in toggleMenu's openClasses array. */
    .max-h-80 { max-height: 20rem !important; }
    .opacity-100 { opacity: 1 !important; }
    .translate-y-0 { transform: translateY(0) !important; }
    .pointer-events-auto { pointer-events: auto !important; }
    .p-2 { padding: 0.5rem !important; }
    .layer-menu{
      width:inherit;
    }
    /* Styled range inputs to match Tailwind look and project palette */
    .layer-menu input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 4px;
      background: transparent;
      border-radius: 9999px;
      outline: none;
      display: block;
    }
    /* WebKit track
       Make the native track transparent so the input's background (a gradient
       applied by JS) shows the filled portion. Provide a fallback background
       color on the input itself for environments with JS disabled. */
    .layer-menu input[type="range"]::-webkit-slider-runnable-track {
      height: 6px;
      background: transparent;
      border-radius: 9999px;
    }
    /* Fallback color when JS hasn't run yet — use our gray palette (light track) */
    .layer-menu input[type="range"] { background-color: #D6D9DE; }
    /* WebKit thumb */
    .layer-menu input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      margin-top: -4px; /* center thumb on track */
      width: 14px;
      height: 14px;
      border-radius: 9999px;
      background: #9CA3AF; /* use bg-gray-400 for the circular thumb */
      box-shadow: 0 1px 3px rgba(0,0,0,0.15);
      border: 2px solid #ffffff;
      cursor: pointer;
    }
    .layer-menu input[type="range"]:focus::-webkit-slider-thumb {
      box-shadow: 0 0 0 4px rgba(42,119,237,0.12);
    }
    /* Firefox track & thumb */
    .layer-menu input[type="range"]::-moz-range-track {
      height: 6px;
      background: #D6D9DE;
      border-radius: 9999px;
    }
    .layer-menu input[type="range"]::-moz-range-thumb {
      width: 14px; height:14px; border-radius:9999px; background:#9CA3AF; border:0; box-shadow:0 1px 3px rgba(0,0,0,0.15);
    }
    /* Firefox: color the filled portion (progress) separately */
    .layer-menu input[type="range"]::-moz-range-progress {
      background: #9CA3AF;
      height: 6px;
      border-radius: 9999px;
    }
    /* Ensure range inputs inside the layer menu size correctly when Tailwind utilities are missing
       or when they're left as `w-full` from earlier edits. Make them behave like flexible children. */
    .layer-menu label { display: flex; align-items: center; }
    .layer-menu input[type="range"].w-full,
    .layer-menu input[type="range"].flex-1 {
      flex: 1 1 auto;
      width: auto;
      min-width: 0;
    }
  </style>
  <!-- Font Awesome for professional icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    /* Ensure Font Awesome solid glyphs render even if loaded late or overridden */
    .fa, .fas, .fa-solid {
      font-family: "Font Awesome 6 Free" !important;
      font-weight: 900 !important;
      /* inherit size from the parent element so icons scale with surrounding text */
      font-size: inherit !important;
      display: inline-block !important;
      line-height: 1 !important;
      vertical-align: middle !important;
      color: inherit !important;
    }
    .fa::before, .fas::before, .fa-solid::before {
      font-family: "Font Awesome 6 Free" !important;
      font-weight: 900 !important;
      display: inline-block !important;
      font-size: inherit !important;
      line-height: 1 !important;
      vertical-align: middle !important;
      color: inherit !important;
    }
    /* Target icons inside compact controls so they appear proportional to buttons */
    .maplibregl-ctrl-group button i,
    .btn-tertiary i,
    .btn-primary i,
    .icon-btn i,
    .layer-menu-btn i,
    .panel-controls i,
    .minimize-btn i {
      font-size: 0.95rem !important;
      line-height: 1 !important;
      vertical-align: middle !important;
    }
    /* Make chevrons and small directional glyphs slightly smaller to fit tight controls */
    .fa-chevron-down, .fa-chevron-up, .fa-chevron-left, .fa-chevron-right,
    .layer-menu-btn i.fa-chevron-down, .layer-menu-btn i.fa-chevron-up,
    .layer-row i.fa-chevron-down, .panel-controls i.fa-chevron-down {
      font-size: 0.65rem !important;
      line-height: 1 !important;
      vertical-align: middle !important;
      transform: none !important;
      /* reduce grayness: lighter, less prominent chevrons */
      color: #9CA3AF !important; /* matches .text-gray-400 */
      opacity: 0.9 !important;
    }
    /* Slightly larger icons when explicitly using text-lg or larger utility classes should still work */
    /* (removed map-control-specific overrides to avoid unintended visibility issues) */
    /* Mobile-only layer control: keep hidden on desktop, show on small screens */
    .pin-btn { display: none !important; }
  </style>
  <style>
    /* Tailwind-like gray utility fallbacks (single-file / no build) */
    .bg-gray-100 { background-color: #F3F4F6 !important; }
    .bg-gray-200 { background-color: #D6D9DE !important; }
    .bg-gray-300 { background-color: #D1D5DB !important; }
    .bg-gray-400 { background-color: #9CA3AF !important; color: #111827 !important; }
    .bg-gray-500 { background-color: #6B7280 !important; color: #fff !important; }

    /* Text and background utility fallbacks (single-file) */

    .bg-white { background-color: #ffffff !important; }
    /* Additional text-gray utilities for later use */
    .text-gray-200 { color: #D6D9DE !important; }
    .text-gray-400 { color: #9CA3AF !important; }
    .text-gray-500 { color: #6B7280 !important; }
    .text-gray-600 { color: #4B5563 !important; }
    .text-gray-800 { color: #1F2937 !important; }

    /* Text size utilities (keep `text-sm` as the sidebar title reference) */
    .text-md { font-size: 1rem !important; }
    .text-sm { font-size: 0.875rem !important; }
    .text-xs { font-size: 0.75rem !important; }
    .text-xxs { font-size: 0.65rem !important; }
    .text-xxxs { font-size: 0.55rem !important; }

    /* Brand text color utilities (four project colors) */
    .text-primary { color: #2A77ED !important; }
    .text-secondary { color: #EDA02A !important; }
    .text-tertiary { color: #ED2AD8 !important; }
    .text-accent { color: #16a085 !important; }

     /* Reusable spacing utilities (Tailwind-like names) - keep as common primitives
       so you can reuse them across panels without adding bespoke CSS later. */
     /* vertical spacing: very extra small (approx 1px) */
     .space-y-xxs > * + * { margin-top: 0.0625rem !important; }
     /* vertical spacing: extra small (approx 2px) - previously added as .space-y-xs */
     .space-y-xs > * + * { margin-top: 0.125rem !important; }
     /* vertical spacing: small (approx 6px) - slightly larger than Tailwind's space-y-1 */
     .space-y-sm > * + * { margin-top: 0.375rem !important; }

     /* horizontal spacing (space-x) primitives for stacked inline items */
     .space-x-xxs > * + * { margin-left: 0.0625rem !important; }
     .space-x-xs > * + * { margin-left: 0.125rem !important; }
     .space-x-sm > * + * { margin-left: 0.375rem !important; }

     /* gap utilities for flex/grid containers */
     .gap-xxs { gap: 0.0625rem !important; }
     .gap-xs { gap: 0.125rem !important; }
     .gap-sm { gap: 0.375rem !important; }
    /* Make native checkboxes and radios use a neutral gray when checked so they don't introduce new colors */
    input[type="checkbox"], input[type="radio"] {
      -webkit-appearance: auto;
      appearance: auto;
      accent-color: #6B7280; /* slightly lighter: text-gray-500 */
    }

  </style>
  <link rel="stylesheet" href="style.css"  />

  <!-- Inter: compact UI font -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
  <style>
    /* Responsive adjustments for small and medium screens
       - Layer panel becomes a bottom drawer on small screens
       - Search box becomes full-width near top
       - Map control group moves to bottom-left on phones and lays out horizontally
       - Legend compresses to avoid overlapping the panel
    */
    @media (max-width: 1024px) {
      /* make layer panel narrower on tablets */
      #layer-panel { width: 340px !important; max-width: 92vw !important; }
      .layer-panel-body { max-height: 60vh; }
    }

    @media (max-width: 640px) {
      /* Layer panel -> bottom drawer */
      #layer-panel {
        left: 0 !important;
        right: 0 !important;
        top: auto !important;
        bottom: 0 !important;
        width: 100% !important;
        max-width: 100% !important;
        height: auto !important;
        max-height: 60vh !important;
        border-radius: 12px 12px 0 0 !important;
        box-shadow: 0 -8px 30px rgba(2,6,23,0.12) !important;
        transform: translateZ(0);
      }
      /* panel header slightly smaller to fit mobile */
      #layer-panel .panel-header { padding: 0.5rem 0.75rem !important; }
      #layer-panel .panel-header .text-sm { font-size: 0.9rem !important; }
      .layer-panel-body { max-height: 50vh !important; overflow: auto !important; }

      /* move map controls to bottom-left and horizontally layout */
      .map-control-container { position: fixed !important; bottom: 1rem !important; left: 0.75rem !important; right: auto !important; z-index: 60 !important; }

      /* Show the small hamburger control on mobile only */
      .pin-btn { display: inline-flex !important; }

    /* Pin state for layer panel: when pinned on mobile, allow larger max-height and keep visible */
    #layer-panel.pinned {
      max-height: calc(100vh - 3.5rem) !important;
      bottom: 0 !important;
    }
    /* Visual state for the pin button when active */
    .pin-btn[aria-pressed="true"] { background: rgba(42,119,237,0.08) !important; }

      .map-control-container.maplibregl-ctrl-group { display: flex !important; flex-direction: row !important; gap: 0.5rem !important; }

      /* search bar full width near top */
      #search-container { left: 0.75rem !important; right: 0.75rem !important; width: auto !important; top: 0.75rem !important; z-index: 70 !important; }
      #search-input { width: 100% !important; }

      /* legend: full-width mobile drawer (no horizontal gaps) */
      /* reduce drawer height slightly (55vh) so more of the map remains visible */
      #layer-panel { max-height: 55vh !important; }
      #map-legend { left: 0 !important; right: 0 !important; bottom: calc(55vh + 0.5rem) !important; width: 100% !important; max-width: none !important; border-radius: 8px !important; }
      /* Reduce the legend content height on small screens so it covers less of the map */
      #map-legend .panel-body { max-height: 25vh !important; overflow: auto !important; }
      /* Use a class-driven collapse so JS can toggle legend content on mobile
        (previously this rule hard-hidden the body preventing the expand button from working) */
      #map-legend.collapsed .panel-body { display: none !important; }

      /* Other small popups should fit mobile width */

      /* reduce padding for layer-menu when collapsed to keep visible space */
      .layer-menu.p-2 { padding: 0.5rem !important; }
    }
    /* Collapsed panel behaviour: ensure collapsed panels shrink to header only */
    .draggable-panel.collapsed { height: auto !important; max-height: none !important; min-height: 0 !important; overflow: visible !important; }
    .draggable-panel.collapsed .panel-body,
    .draggable-panel.collapsed .layer-panel-body { display: none !important; }
    /* make sure layer header remains visible and compact when collapsed */
    .draggable-panel.collapsed .panel-header { border-radius: 8px; }
    /* Non-small screens: reduce panel widths (~25% narrower) so they are less dominant
       This applies from tablet upward (>= 641px) and preserves existing small-screen rules. */
    @media (min-width: 641px) {
      /* layer-panel: slightly wider than the previous reduction — increase a bit for readability */
      /* set to 22.5% (slightly less than original 25%) with a sensible max-width */
      #layer-panel { width: 22.5% !important; max-width: 32rem !important; }
      /* legend default width ~14rem (w-56) — reduce by 25% to 10.5rem */
      #map-legend { width: 10.5rem !important; max-width: 10.5rem !important; }
      /* reduce legend body height by ~25% (from 48vh -> 36vh) to cover less map on normal screens */
      #map-legend .panel-body { max-height: 32vh; overflow: auto; }
    }
  </style>
  
</head>
<body class="h-full overflow-hidden font-sans">
  <div id="map" class="w-full h-screen"></div>
  <div id="search-container" class="absolute left-20 top-3 z-30 w-auto">
    <div class="relative flex gap-2 items-start">
      <input id="search-input" type="search" placeholder="Search place or address..." autocomplete="off" class="px-3 py-2 border border-gray-200 rounded-md bg-white text-xs focus:outline-none focus:ring-2 focus:ring-sky-200 h-9 w-64" />
      <!-- Glacier location buttons right after search bar -->
      <div id="glacier-nav-container" class="flex gap-1">
        <button id="glacier-thulagi" class="glacier-nav-btn btn-primary text-xs" title="Fly to Thulagi">Thulagi</button>
        <button id="glacier-lumding" class="glacier-nav-btn btn-secondary text-xs" title="Fly to Lumding Tsho">Lumding Tsho</button>
        <button id="glacier-hongu" class="glacier-nav-btn btn-secondary text-xs" title="Fly to Hongu2">Hongu2</button>
        <button id="glacier-barun" class="glacier-nav-btn btn-secondary text-xs" title="Fly to Lower Barun">Lower Barun</button>
      </div>
    </div>
    <div id="search-results" class="mt-2 bg-white rounded-md shadow-lg max-h-56 overflow-auto"></div>
  </div>
  <div id="map-legend" class="draggable-panel map-legend absolute left-3 bottom-3 w-56 max-w-xs z-20 bg-white rounded-lg shadow-lg" role="dialog" aria-label="Map legend">
    <div class="panel-header flex items-center justify-between p-3 pb-1 pt-1 border-b border-gray-100">
      <strong class="text-xs">Legend</strong>
      <div class="panel-controls flex items-center gap-2">
        <span class="panel-icon hidden" aria-hidden="true"><i class="fa-solid fa-bars text-lg text-slate-800"></i></span>
        <button class="minimize-btn btn-tertiary w-8 h-8 p-0 inline-flex items-center justify-center" data-target="map-legend" aria-label="Minimize legend" aria-expanded="true"><i class="fa-solid fa-minus" aria-hidden="true"></i></button>
      </div>
    </div>
    <div class="panel-body p-3 pt-0 space-y-2 max-h-64 overflow-auto">
      <!-- Polygons: filled swatch -->
      <div class="flex items-center gap-3">
        <div class="w-4 h-3 rounded-sm shadow-inner" style="background:#2A77ED;"></div>
        <div class="flex-1 text-xxs text-gray-600">Glaciers (polygons)</div>
      </div>

      <div class="flex items-center gap-3">
        <div class="w-4 h-3 rounded-sm shadow-inner" style="background:#16a085;"></div>
        <div class="flex-1 text-xxs text-gray-600">Glacial lakes</div>
      </div>

      <div class="flex items-center gap-3">
        <div class="w-4 h-3 rounded-sm shadow-inner" style="background:#16a085; opacity:0.9;"></div>
        <div class="flex-1 text-xxs text-gray-600">Protected areas</div>
      </div>

      <!-- Lines: horizontal stroke -->
      <div class="flex items-center gap-3">
        <div class="w-10 h-1 rounded" style="background:#2A77ED;"></div>
        <div class="flex-1 text-xxs text-gray-600">Rivers</div>
      </div>

      <div class="flex items-center gap-3">
        <div class="w-10 h-1 rounded" style="background:#EDA02A;"></div>
        <div class="flex-1 text-xxs text-gray-600">Roads</div>
      </div>

      <!-- Points: circular marker -->
      <div class="flex items-center gap-3">
        <div class="w-3 h-3 rounded-full shadow-inner" style="background:#34495e;"></div>
        <div class="flex-1 text-xxs text-gray-600">Settlements</div>
      </div>

      <div class="flex items-center gap-3">
        <div class="w-3 h-3 rounded-full shadow-inner" style="background:#ED2AD8;"></div>
        <div class="flex-1 text-xxs text-gray-600">Peaks</div>
      </div>

      <div class="flex items-center gap-3">
        <div class="w-3 h-3 rounded-full shadow-inner" style="background:#e67e22;"></div>
        <div class="flex-1 text-xxs text-gray-600">Airports</div>
      </div>

      <!-- Municipality boundary: line symbol -->
      <div class="flex items-center gap-3">
        <div class="w-10 h-1 rounded" style="background:#34495e;"></div>
        <div class="flex-1 text-xxs text-gray-600">Municipalities (boundary)</div>
      </div>
    </div>
  </div>


  <!-- Webmap Title: top right, above layer panel -->
  
  <div id="layer-panel" class="draggable-panel layer-panel absolute right-3 top-3 w-1/4 max-w-md z-20 h-screen flex flex-col bg-white/95 shadow-lg rounded-lg pb-4">
    <div class="panel-header flex items-center justify-between p-3 border-b bg-primary border-gray-100 rounded-lg-top">
      <div class="text-sm font-semibold text-gray-200">MeinSalzburg | Salzburg Urban Toolkit</div>
      <div class="panel-controls flex items-center gap-2">
        <button class="minimize-btn btn-tertiary w-8 h-8 p-0 inline-flex items-center justify-center" data-target="layer-panel" aria-label="Minimize layers" aria-expanded="true"><i class="fa-solid fa-minus text-gray-200" aria-hidden="true"></i></button>
      </div>
    </div>
    <div class="layer-panel-body overflow-auto p-2">
      <div class="mb-3">
        <div class="flex items-center justify-between mb-2">
          <h4 class="text-xs font-semibold text-slate-600">Base Layers</h4>
          <div class="flex items-center gap-3">
            <label class="text-xxs text-gray-600 mr-2">3D</label>
            <label id="switch-3d" class="switch switch-xxs inline-flex items-center gap-3 cursor-pointer">
              <input id="toggle-3d" type="checkbox" class="sr-only" aria-label="Toggle 3D view" />
              <div class="switch-track">
                <div class="switch-knob"></div>
              </div>
            </label>
          </div>
        </div>
        <div class="mb-3">
          <div class="flex flex-col gap-2 pb-2">
            <label class="flex items-center gap-3"><input type="radio" name="basemap" value="street" id="basemap-street-radio"> <span class="text-xs text-gray-600">Street</span></label>
            <label class="flex items-center gap-3"><input type="radio" name="basemap" value="satellite" id="basemap-sat-radio" checked> <span class="text-xs text-gray-600">Satellite</span></label>
          </div>
        </div>

      <h4 class="text-xs font-semibold text-slate-600 mt-3 mb-2">Overlay Layers</h4>
      <div class="space-y-xs">
        <!-- Glaciers (polygons) -->
        <div class="flex items-center justify-between bg-white/60 rounded hover:bg-sky-50 hover:-translate-y-0.5 transform transition layer-row">
          <div class="flex items-center gap-3"><input type="checkbox" id="layer-glaciers-visible" checked><label for="layer-glaciers-visible" class="text-xs text-gray-600">Glaciers (polygons)</label></div>
          <button class="layer-menu-btn btn-tertiary w-8 h-8 p-0 inline-flex items-center justify-center" aria-expanded="false" aria-label="Toggle layer options"><i class="fa-solid fa-chevron-down" aria-hidden="true"></i></button>
        </div>
        <div class="layer-menu mt-2 bg-white shadow rounded w-full sm:w-72 overflow-hidden transition-all duration-200 max-h-0 opacity-0 -translate-y-1 pointer-events-none p-0">
          <label class="flex items-center justify-between gap-2"><span class="text-xxs text-gray-600">Labels</span><input type="checkbox" id="layer-glaciers-labels"></label>
          <label class="flex items-center justify-between gap-2 mt-2"><span class="text-xxs text-gray-600">Opacity</span><input type="range" id="layer-glaciers-opacity" min="0" max="1" step="0.05" value="0.25" class="ml-3 w-full"></label>
        </div>

        <!-- Glacial lakes (polygons) -->
        <div class="flex items-center justify-between bg-white/60 rounded hover:bg-sky-50 hover:-translate-y-0.5 transform transition layer-row">
          <div class="flex items-center gap-3"><input type="checkbox" id="layer-glacial-lakes-visible" checked><label for="layer-glacial-lakes-visible" class="text-xs text-gray-600">Glacial lakes</label></div>
          <button class="layer-menu-btn btn-tertiary w-8 h-8 p-0 inline-flex items-center justify-center" aria-expanded="false" aria-label="Toggle layer options"><i class="fa-solid fa-chevron-down" aria-hidden="true"></i></button>
        </div>
        <div class="layer-menu mt-2 bg-white shadow rounded w-full sm:w-72 overflow-hidden transition-all duration-200 max-h-0 opacity-0 -translate-y-1 pointer-events-none p-0">
          <label class="flex items-center justify-between gap-2"><span class="text-xxs text-gray-600">Labels</span><input type="checkbox" id="layer-glacial-lakes-labels"></label>
          <label class="flex items-center justify-between gap-2 mt-2"><span class="text-xxs text-gray-600">Opacity</span><input type="range" id="layer-glacial-lakes-opacity" min="0" max="1" step="0.05" value="0.35" class="ml-3 w-full"></label>
        </div>

        <!-- Glacier points -->
        <div class="flex items-center justify-between bg-white/60 rounded hover:bg-sky-50 hover:-translate-y-0.5 transform transition layer-row">
          <div class="flex items-center gap-3"><input type="checkbox" id="layer-glacier-points-visible" checked><label for="layer-glacier-points-visible" class="text-xs text-gray-600">Glacier points</label></div>
          <button class="layer-menu-btn btn-tertiary w-8 h-8 p-0 inline-flex items-center justify-center" aria-expanded="false" aria-label="Toggle layer options"><i class="fa-solid fa-chevron-down" aria-hidden="true"></i></button>
        </div>
        <div class="layer-menu mt-2 bg-white shadow rounded w-full sm:w-72 overflow-hidden transition-all duration-200 max-h-0 opacity-0 -translate-y-1 pointer-events-none p-0">
          <label class="flex items-center justify-between gap-2"><span class="text-xxs text-gray-600">Labels</span><input type="checkbox" id="layer-glacier-points-labels"></label>
          <label class="flex items-center justify-between gap-2 mt-2"><span class="text-xxs text-gray-600">Opacity</span><input type="range" id="layer-glacier-points-opacity" min="0" max="1" step="0.05" value="0.9" class="ml-3 w-full"></label>
        </div>

        <!-- Peaks (points) -->
        <div class="flex items-center justify-between bg-white/60 rounded hover:bg-sky-50 hover:-translate-y-0.5 transform transition layer-row">
          <div class="flex items-center gap-3"><input type="checkbox" id="layer-peaks-visible" checked><label for="layer-peaks-visible" class="text-xs text-gray-600">Peaks</label></div>
          <button class="layer-menu-btn btn-tertiary w-8 h-8 p-0 inline-flex items-center justify-center" aria-expanded="false" aria-label="Toggle layer options"><i class="fa-solid fa-chevron-down" aria-hidden="true"></i></button>
        </div>
        <div class="layer-menu mt-2 bg-white shadow rounded w-full sm:w-72 overflow-hidden transition-all duration-200 max-h-0 opacity-0 -translate-y-1 pointer-events-none p-0">
          <label class="flex items-center justify-between gap-2"><span class="text-xxs text-gray-600">Labels</span><input type="checkbox" id="layer-peaks-labels"></label>
          <label class="flex items-center justify-between gap-2 mt-2"><span class="text-xxs text-gray-600">Opacity</span><input type="range" id="layer-peaks-opacity" min="0" max="1" step="0.05" value="0.9" class="ml-3 w-full"></label>
        </div>

        <!-- Settlements (points) -->
        <div class="flex items-center justify-between bg-white/60 rounded hover:bg-sky-50 hover:-translate-y-0.5 transform transition layer-row">
          <div class="flex items-center gap-3"><input type="checkbox" id="layer-settlements-visible" checked><label for="layer-settlements-visible" class="text-xs text-gray-600">Settlements</label></div>
          <button class="layer-menu-btn btn-tertiary w-8 h-8 p-0 inline-flex items-center justify-center" aria-expanded="false" aria-label="Toggle layer options"><i class="fa-solid fa-chevron-down" aria-hidden="true"></i></button>
        </div>
        <div class="layer-menu mt-2 bg-white shadow rounded w-full sm:w-72 overflow-hidden transition-all duration-200 max-h-0 opacity-0 -translate-y-1 pointer-events-none p-0">
          <label class="flex items-center justify-between gap-2"><span class="text-xxs text-gray-600">Labels</span><input type="checkbox" id="layer-settlements-labels"></label>
          <label class="flex items-center justify-between gap-2 mt-2"><span class="text-xxs text-gray-600">Opacity</span><input type="range" id="layer-settlements-opacity" min="0" max="1" step="0.05" value="0.9" class="ml-3 w-full"></label>
        </div>

        <!-- Airports -->
        <div class="flex items-center justify-between bg-white/60 rounded hover:bg-sky-50 hover:-translate-y-0.5 transform transition layer-row">
          <div class="flex items-center gap-3"><input type="checkbox" id="layer-airports-visible" checked><label for="layer-airports-visible" class="text-xs text-gray-600">Airports</label></div>
          <button class="layer-menu-btn btn-tertiary w-8 h-8 p-0 inline-flex items-center justify-center" aria-expanded="false" aria-label="Toggle layer options"><i class="fa-solid fa-chevron-down" aria-hidden="true"></i></button>
        </div>
        <div class="layer-menu mt-2 bg-white shadow rounded w-full sm:w-72 overflow-hidden transition-all duration-200 max-h-0 opacity-0 -translate-y-1 pointer-events-none p-0">
          <label class="flex items-center justify-between gap-2"><span class="text-xxs text-gray-600">Labels</span><input type="checkbox" id="layer-airports-labels"></label>
          <label class="flex items-center justify-between gap-2 mt-2"><span class="text-xxs text-gray-600">Opacity</span><input type="range" id="layer-airports-opacity" min="0" max="1" step="0.05" value="0.9" class="ml-3 w-full"></label>
        </div>

        <!-- Protected areas -->
        <div class="flex items-center justify-between bg-white/60 rounded hover:bg-sky-50 hover:-translate-y-0.5 transform transition layer-row">
          <div class="flex items-center gap-3"><input type="checkbox" id="layer-protected-areas-visible" checked><label for="layer-protected-areas-visible" class="text-xs text-gray-600">Protected areas</label></div>
          <button class="layer-menu-btn btn-tertiary w-8 h-8 p-0 inline-flex items-center justify-center" aria-expanded="false" aria-label="Toggle layer options"><i class="fa-solid fa-chevron-down" aria-hidden="true"></i></button>
        </div>
        <div class="layer-menu mt-2 bg-white shadow rounded w-full sm:w-72 overflow-hidden transition-all duration-200 max-h-0 opacity-0 -translate-y-1 pointer-events-none p-0">
          <label class="flex items-center justify-between gap-2"><span class="text-xxs text-gray-600">Labels</span><input type="checkbox" id="layer-protected-areas-labels"></label>
          <label class="flex items-center justify-between gap-2 mt-2"><span class="text-xxs text-gray-600">Opacity</span><input type="range" id="layer-protected-areas-opacity" min="0" max="1" step="0.05" value="0.2" class="ml-3 w-full"></label>
        </div>

        <!-- Rivers -->
        <div class="flex items-center justify-between bg-white/60 rounded hover:bg-sky-50 hover:-translate-y-0.5 transform transition layer-row">
          <div class="flex items-center gap-3"><input type="checkbox" id="layer-rivers-visible" checked><label for="layer-rivers-visible" class="text-xs text-gray-600">Rivers</label></div>
          <button class="layer-menu-btn btn-tertiary w-8 h-8 p-0 inline-flex items-center justify-center" aria-expanded="false" aria-label="Toggle layer options"><i class="fa-solid fa-chevron-down" aria-hidden="true"></i></button>
        </div>
        <div class="layer-menu mt-2 bg-white shadow rounded w-full sm:w-72 overflow-hidden transition-all duration-200 max-h-0 opacity-0 -translate-y-1 pointer-events-none p-0">
          <label class="flex items-center justify-between gap-2"><span class="text-xxs text-gray-600">Labels</span><input type="checkbox" id="layer-rivers-labels"></label>
          <label class="flex items-center justify-between gap-2 mt-2"><span class="text-xxs text-gray-600">Opacity</span><input type="range" id="layer-rivers-opacity" min="0" max="1" step="0.05" value="1" class="ml-3 w-full"></label>
        </div>

        <!-- Roads -->
        <div class="flex items-center justify-between bg-white/60 rounded hover:bg-sky-50 hover:-translate-y-0.5 transform transition layer-row">
          <div class="flex items-center gap-3"><input type="checkbox" id="layer-roads-visible" checked><label for="layer-roads-visible" class="text-xs text-gray-600">Roads</label></div>
          <button class="layer-menu-btn btn-tertiary w-8 h-8 p-0 inline-flex items-center justify-center" aria-expanded="false" aria-label="Toggle layer options"><i class="fa-solid fa-chevron-down" aria-hidden="true"></i></button>
        </div>
        <div class="layer-menu mt-2 bg-white shadow rounded w-full sm:w-72 overflow-hidden transition-all duration-200 max-h-0 opacity-0 -translate-y-1 pointer-events-none p-0">
          <label class="flex items-center justify-between gap-2"><span class="text-xxs text-gray-600">Labels</span><input type="checkbox" id="layer-roads-labels"></label>
          <label class="flex items-center justify-between gap-2 mt-2"><span class="text-xxs text-gray-600">Opacity</span><input type="range" id="layer-roads-opacity" min="0" max="1" step="0.05" value="1" class="ml-3 w-full"></label>
        </div>

        <!-- Municipalities (boundary) -->
        <div class="flex items-center justify-between bg-white/60 rounded hover:bg-sky-50 hover:-translate-y-0.5 transform transition layer-row">
          <div class="flex items-center gap-3"><input type="checkbox" id="layer-municipalities-visible" checked><label for="layer-municipalities-visible" class="text-xs text-gray-600">Municipalities</label></div>
          <button class="layer-menu-btn btn-tertiary w-8 h-8 p-0 inline-flex items-center justify-center" aria-expanded="false" aria-label="Toggle layer options"><i class="fa-solid fa-chevron-down" aria-hidden="true"></i></button>
        </div>
        <div class="layer-menu mt-2 bg-white shadow rounded w-full sm:w-72 overflow-hidden transition-all duration-200 max-h-0 opacity-0 -translate-y-1 pointer-events-none p-0">
          <label class="flex items-center justify-between gap-2"><span class="text-xxs text-gray-600">Labels</span><input type="checkbox" id="layer-municipalities-labels"></label>
          <label class="flex items-center justify-between gap-2 mt-2"><span class="text-xxs text-gray-600">Opacity</span><input type="range" id="layer-municipalities-opacity" min="0" max="1" step="0.05" value="1" class="ml-3 w-full"></label>
        </div>
      </div>

      <div class="panel-sep my-3 border-t pt-3"></div>


      <div class="panel-sep my-4 border-t pt-3"></div>
      <div class="text-xs text-slate-600">Data sources</div>
      <div class="mt-2 text-xs text-slate-700">
        <div class="data-credit mt-2 text-xs text-slate-700">Data Source: Survey Department, Department of Hydrology and Meteorology Nepal. 
        </div>
    </div>
  </div>

  <!-- Removed mobile pin/hamburger control per UX request. -->

  <!-- Centralize panel collapse/expand behavior: helper + wiring -->
  <script>
    (function(){
      function setPanelCollapsed(panel, collapsed){
        if (!panel) return;
        // maintain collapsed class (used by CSS) but also control inline styles to avoid !important collisions
        if (collapsed) panel.classList.add('collapsed'); else panel.classList.remove('collapsed');

        // prefer semantic selectors for body (panel-body or layer-panel-body)
        const body = panel.querySelector('.panel-body') || panel.querySelector('.layer-panel-body');
        if (body){
          // use inline styles so we can override any CSS !important rules reliably
          if (collapsed) {
            body.classList.add('hidden');
            // ensure hidden using inline style (use important to override stylesheet rules)
            try { body.style.setProperty('display', 'none', 'important'); } catch(e){ body.style.display = 'none'; }
          } else {
            // remove hidden marker and any inline display override
            body.classList.remove('hidden');
            try { body.style.removeProperty('display'); } catch(e){ body.style.display = ''; }
          }
          // expose state for screen readers
          body.setAttribute('aria-hidden', collapsed ? 'true' : 'false');
        }

        // update minimize icon if present
        const minBtn = panel.querySelector('.minimize-btn');
        if (minBtn){
          const icon = minBtn.querySelector('i');
          if (icon){
            icon.classList.toggle('fa-minus', !collapsed);
            icon.classList.toggle('fa-plus', collapsed);
          }
          // keep explicit attributes for automation and accessibility
          minBtn.setAttribute('data-collapsed', collapsed ? 'true' : 'false');
          minBtn.setAttribute('aria-expanded', (!collapsed).toString());
        }

        // On small screens, keep only one drawer visible at a time: if the
        // user opens the legend, collapse the layer panel and vice-versa.
        try {
          if (window.innerWidth <= 640) {
            const pid = panel.id;
            if (!pid) {
              // nothing to do
            } else if (!collapsed && pid === 'map-legend') {
              // legend is being opened on mobile — collapse layer panel
              const other = document.getElementById('layer-panel');
              if (other) setPanelCollapsed(other, true);
            } else if (!collapsed && pid === 'layer-panel') {
              // layer panel is being opened on mobile — collapse legend
              const other = document.getElementById('map-legend');
              if (other) setPanelCollapsed(other, true);
            }
          }
        } catch (e) {}

        // After changing panel state, adjust legend position (mobile) so panels stack nicely
        try { updateLegendPosition(); } catch (e) {}
      }

      // Compute and set legend position so it sits immediately above the minimized layer panel on small screens.
      // This function uses inline style with `important` to override mobile stylesheet rules such as
      // `#map-legend { bottom: calc(55vh + 1rem) !important; }` when the layer panel is collapsed.
      function updateLegendPosition(){
        const legend = document.getElementById('map-legend');
        const layer = document.getElementById('layer-panel');
        if (!legend) return;
        
        // Toggle margin-bottom utility on small screens so the legend has
        // extra spacing when displayed above the mobile drawer.
        try {
          if (window.innerWidth <= 640) legend.classList.add('mb-5'); else legend.classList.remove('mb-5');
        } catch (e) {}
        // On narrow screens we want the legend to float just above the minimized layer header
        if (window.innerWidth <= 640 && layer){
          if (layer.classList.contains('collapsed')){
            const header = layer.querySelector('.panel-header');
            const headerH = header ? header.getBoundingClientRect().height : 48;
            const gap = 4; // px gap between legend and minimized header (reduced for tighter stacking)
            // set inline bottom with important to override any !important stylesheet rules
            try {
              legend.style.setProperty('bottom', (headerH + gap) + 'px', 'important');
            } catch (e) {
              legend.style.bottom = (headerH + gap) + 'px';
            }
            return;
          }
        }

        // Restore default placement when not collapsed or on larger screens
        try { legend.style.removeProperty('bottom'); } catch(e) { legend.style.bottom = ''; }
      }

      // wire minimize buttons to call the helper directly
      function wireMinimizers(){
        const panels = document.querySelectorAll('.draggable-panel');
        panels.forEach(panel => {
          const minBtn = panel.querySelector('.minimize-btn');
          if (!minBtn) return;
          minBtn.addEventListener('click', function(){
            const body = panel.querySelector('.panel-body') || panel.querySelector('.layer-panel-body');
            const currentlyCollapsed = body ? body.classList.contains('hidden') : panel.classList.contains('collapsed');
            // toggle collapsed state
            setPanelCollapsed(panel, !currentlyCollapsed);
          });
        });
      }

      // on DOM ready wire everything
      if (document.readyState !== 'loading') {
        wireMinimizers();
        // On small screens start with layers collapsed and legend open so map remains visible
        if (window.innerWidth <= 640){ const legend = document.getElementById('map-legend'); const layer = document.getElementById('layer-panel'); if (layer) setPanelCollapsed(layer, true); if (legend) setPanelCollapsed(legend, false); }
      } else document.addEventListener('DOMContentLoaded', () => {
        wireMinimizers();
        // On small screens start with layers collapsed and legend open (mobile drawer UX)
        if (window.innerWidth <= 640){ const legend = document.getElementById('map-legend'); const layer = document.getElementById('layer-panel'); if (layer) setPanelCollapsed(layer, true); if (legend) setPanelCollapsed(legend, false); }
      });
      // Recompute legend position on resize so stacked layout stays correct
      let __legendResizeTimer = null;
      window.addEventListener('resize', function(){
        clearTimeout(__legendResizeTimer);
        __legendResizeTimer = setTimeout(updateLegendPosition, 120);
      });
    
    })();
  </script>


  <script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.8.0/proj4.js"></script>
  <script>
    //map initialization
    // Use a minimal/empty style so our raster OSM layer becomes the visible basemap
    const map = new maplibregl.Map({
      container: "map",
      // Use the public MapLibre demo style which includes a working `glyphs` URL
      style: 'https://demotiles.maplibre.org/style.json',
      center: [ 85.8, 27.5],
      zoom: 10,
      pitch: 0,  // Start with 0 pitch, enable 3D only after terrain loads
      preserveDrawingBuffer: true  // Required for canvas export (map screenshots)
    });

    // ------------------------- Simple Nominatim search -------------------------
    let searchMarker = null;

    // debounce helper
    function debounce(fn, wait) {
      let t = null;
      return function(...args) {
        clearTimeout(t);
        t = setTimeout(() => fn.apply(this, args), wait);
      };
    }

    const input = document.getElementById('search-input');
    const resultsDiv = document.getElementById('search-results');

    async function doSearch(query) {
      if (!query || query.length < 3) {
        resultsDiv.innerHTML = '';
        return;
      }

      const url = `https://nominatim.openstreetmap.org/search?format=json&limit=6&q=${encodeURIComponent(query)}`;
      try {
        const res = await fetch(url, {
          headers: { 'Accept-Language': 'en' }
        });
        const json = await res.json();
        renderResults(json);
      } catch (err) {
        console.error('Search error', err);
        resultsDiv.innerHTML = '';
      }
    }

    function renderResults(items) {
      if (!items || !items.length) {
        resultsDiv.innerHTML = '';
        return;
      }

      resultsDiv.innerHTML = items.map((it, i) =>
        `<div class="search-item text-xxs text-gray-600 p-2" data-lon="${it.lon}" data-lat="${it.lat}">${it.display_name}</div>`
      ).join('');

      // attach click handlers
      Array.from(resultsDiv.querySelectorAll('.search-item')).forEach(el => {
        el.addEventListener('click', () => {
          const lon = parseFloat(el.getAttribute('data-lon'));
          const lat = parseFloat(el.getAttribute('data-lat'));
          // fly to place
          map.flyTo({ center: [lon, lat], zoom: 13 });

          // add or move marker (use project primary color)
          if (!searchMarker) {
            searchMarker = new maplibregl.Marker({ color: '#2A77ED' }).setLngLat([lon, lat]).addTo(map);
          } else {
            searchMarker.setLngLat([lon, lat]);
          }

          resultsDiv.innerHTML = '';
          input.value = '';
        });
      });
    }

    const debouncedSearch = debounce((e) => doSearch(e.target.value), 300);
    input.addEventListener('input', debouncedSearch);
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        resultsDiv.innerHTML = '';
        input.value = '';
      }
    });


    
    // ------------------------------------Data Sources and Layers------------------------------------  //
    // Load all GeoJSON data sources and add them as layers
      // Add all GeoJSON sources
    // ------------------------------------choropleth layer------------------------------------  //
    // Add DEM source + enable 3D terrain, then GeoJSON source and layers
    
    // Add error event listener to catch tile loading failures
    map.on('error', (e) => {
      // Suppress 404 errors from tile loading (they're not critical)
      if (e.error && e.error.status === 404) {
        console.debug('Tile not found (404):', e.error.url);
        return;
      }
      if (e.error && e.error.message && e.error.message.includes('wrap')) {
        console.debug('Terrain wrap error (non-critical):', e.error.message);
        return;
      }
      console.warn('Map error:', e);
    });

    map.on("load", () => {
      // Add a raster-dem source using the free Terrarium tiles hosted on S3.
      // This source does not require an API key and uses the "terrarium" encoding.
      try {
        map.addSource('dem', {
          type: 'raster-dem',
          tiles: [
            'https://s3.amazonaws.com/elevation-tiles-prod/terrarium/{z}/{x}/{y}.png'
          ],
          tileSize: 256,
          maxzoom: 15,
          encoding: 'terrarium'
        });

        // Enable 3D terrain after a short delay to ensure source is ready
        // Increase the `exaggeration` value if you want a stronger effect.
        setTimeout(() => {
          try {
            map.setTerrain({ source: 'dem', exaggeration: 1.2});
            map.setPitch(45); // Enable 3D perspective after terrain is loaded
          } catch (e) {
            console.warn('Failed to enable terrain:', e);
          }
        }, 500);
      } catch (e) {
        console.warn('Failed to add DEM source:', e);
        // Continue without terrain if DEM fails
      }

      // Note: removed sky layer because this MapLibre build may not support 'sky' layer type.
      // Leaving terrain enabled but skipping the sky layer to avoid style validation errors.

      // --- Base map raster sources & layers (Street and Satellite) - ADD FIRST SO THEY'RE BELOW ---
      // Street (OpenStreetMap)
      map.addSource('basemap-street-source', {
        type: 'raster',
        // use explicit subdomain URLs (a, b, c) instead of a range placeholder
        tiles: [
          'https://a.tile.openstreetmap.org/{z}/{x}/{y}.png',
          'https://b.tile.openstreetmap.org/{z}/{x}/{y}.png',
          'https://c.tile.openstreetmap.org/{z}/{x}/{y}.png'
        ],
        tileSize: 256,
        attribution: '© OpenStreetMap contributors'
      });

      // Satellite (Esri World Imagery)
      map.addSource('basemap-satellite-source', {
        type: 'raster',
        tiles: [
          'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'
        ],
        tileSize: 256,
        attribution: 'Tiles © Esri'
      });

      // Add street raster layer (visible by default)
      map.addLayer({
        id: 'basemap-street',
        type: 'raster',
        source: 'basemap-street-source',
        layout: { 'visibility': 'none' }
      });

      // Add satellite raster layer (hidden by default)
      map.addLayer({
        id: 'basemap-satellite',
        type: 'raster',
        source: 'basemap-satellite-source'
      });

      // Create empty GeoJSON sources for the replaced project datasets. We'll fetch and
      // populate them dynamically and reproject if needed (some datasets come in UTM/SRID other than WGS84).
      const emptyFC = { type: 'FeatureCollection', features: [] };

      const newSources = ['glaciers','glacial-lakes','glacier-points','peaks','settlements','airports','protected-areas','rivers','roads','municipalities'];
      newSources.forEach(s => map.addSource(s, { type: 'geojson', data: emptyFC }));

      // Layers: polygons first (fills), then outlines and lines, then points.
      map.addLayer({ id: 'glaciers-fill', type: 'fill', source: 'glaciers', paint: { 'fill-color': '#2A77ED', 'fill-opacity': 0.25 } });
      map.addLayer({ id: 'glaciers-outline', type: 'line', source: 'glaciers', paint: { 'line-color': '#1f4b8f', 'line-width': 1.8 } });

      map.addLayer({ id: 'glacial-lakes-fill', type: 'fill', source: 'glacial-lakes', paint: { 'fill-color': '#16a085', 'fill-opacity': 0.35 } });
      map.addLayer({ id: 'glacial-lakes-outline', type: 'line', source: 'glacial-lakes', paint: { 'line-color': '#0f7760', 'line-width': 1.5 } });

      map.addLayer({ id: 'protected-areas-fill', type: 'fill', source: 'protected-areas', paint: { 'fill-color': '#16a085', 'fill-opacity': 0.14 } });
      map.addLayer({ id: 'protected-areas-outline', type: 'line', source: 'protected-areas', paint: { 'line-color': '#0f7760', 'line-width': 1 } });

      // Add a subtle fill for municipalities so boundaries can be rendered as polygons
      map.addLayer({ id: 'municipalities-fill', type: 'fill', source: 'municipalities', paint: { 'fill-color': '#34495e', 'fill-opacity': 0.06 } });
      map.addLayer({ id: 'municipalities-outline', type: 'line', source: 'municipalities', paint: { 'line-color': '#34495e', 'line-width': 1.6 } });

      map.addLayer({ id: 'rivers-layer', type: 'line', source: 'rivers', paint: { 'line-color': '#2A77ED', 'line-width': 2 } });
      map.addLayer({ id: 'roads-layer', type: 'line', source: 'roads', paint: { 'line-color': '#EDA02A', 'line-width': 1.6 } });

      // Points
      map.addLayer({ id: 'glacier-points-layer', type: 'circle', source: 'glacier-points', paint: { 'circle-radius': 5, 'circle-color': '#2A77ED', 'circle-opacity': 0.9 } });
      map.addLayer({ id: 'peaks-layer', type: 'circle', source: 'peaks', paint: { 'circle-radius': 4, 'circle-color': '#ED2AD8', 'circle-opacity': 0.95 } });
      map.addLayer({ id: 'settlements-layer', type: 'circle', source: 'settlements', paint: { 'circle-radius': 4, 'circle-color': '#34495e', 'circle-opacity': 0.9 } });
      map.addLayer({ id: 'airports-layer', type: 'circle', source: 'airports', paint: { 'circle-radius': 6, 'circle-color': '#e67e22', 'circle-opacity': 0.95 } });

      // Helper: reproject GeoJSON to EPSG:4326 when necessary using proj4.
      function getEpsgFromCrs(gj) {
        try {
          if (!gj || !gj.crs || !gj.crs.properties || !gj.crs.properties.name) return null;
          return gj.crs.properties.name; // e.g. 'urn:ogc:def:crs:EPSG::32645' or 'urn:ogc:def:crs:OGC:1.3:CRS84'
        } catch (e) { return null; }
      }

      // Define proj4 defs we know are used in these files. Add more if needed.
      if (typeof proj4 !== 'undefined') {
        try { proj4.defs('EPSG:32645', '+proj=utm +zone=45 +datum=WGS84 +units=m +no_defs'); } catch (e) {}
      }

      function reprojectGeoJSON(gj) {
        if (!gj || !gj.type) return gj;
        const crs = getEpsgFromCrs(gj);
        // If CRS indicates WGS84 / CRS84 / EPSG:4326, assume coordinates are lon/lat already.
        if (!crs) return gj;
        const lower = (crs + '').toLowerCase();
        if (lower.includes('crs84') || lower.includes('epsg:4326') || lower.includes('epsg::4326')) return gj;

        // Try to extract EPSG code
        const m = crs.match(/(epsg[:]{0,1}[:]{0,1})(\d+)/i) || crs.match(/::(\d+)$/);
        let code = null;
        if (m) code = 'EPSG:' + (m[2] || m[1]);
        if (!code) return gj;
        if (typeof proj4 === 'undefined') return gj;

        const from = code;
        const to = 'EPSG:4326';

        function reprojectCoords(coords) {
          if (typeof coords[0] === 'number' && typeof coords[1] === 'number') {
            return proj4(from, to, coords);
          }
          return coords.map(reprojectCoords);
        }

        const out = JSON.parse(JSON.stringify(gj));
        out.features = (out.features || []).map(f => {
          if (!f.geometry) return f;
          f.geometry.coordinates = reprojectCoords(f.geometry.coordinates);
          return f;
        });
        return out;
      }

      // fetch and populate each source file, reprojecting if necessary
      const fetchList = [
        { src: 'glaciers', url: 'data/glaciers_polygon.geojson' },
        { src: 'glacial-lakes', url: 'data/glacial_lake_polygon.geojson' },
        { src: 'glacier-points', url: 'data/glacier_points.geojson' },
        { src: 'peaks', url: 'data/peaks.geojson' },
        { src: 'settlements', url: 'data/settlements.geojson' },
        { src: 'airports', url: 'data/airports.geojson' },
        { src: 'protected-areas', url: 'data/protected_areas.geojson' },
        { src: 'rivers', url: 'data/rivers.geojson' },
        { src: 'roads', url: 'data/roads.geojson' },
        { src: 'municipalities', url: 'data/municipalities_clipped.geojson' }
      ];

      // Load each GeoJSON and keep a reference so we can inspect properties per-source later.
      window._loadedSources = window._loadedSources || {};
      fetchList.forEach(item => {
        fetch(item.url).then(r => r.json()).then(j => {
          try {
            const out = reprojectGeoJSON(j);
            const s = map.getSource(item.src);
            if (s) s.setData(out);
            // store loaded data for later per-layer label property detection
            window._loadedSources[item.src] = out;
          } catch (e) { console.warn('Failed to set data for', item.src, e); }
        }).catch(err => { console.warn('Could not load', item.url, err); });
      });

      // Wire up radio buttons to toggle the base layers
      const basemapRadios = document.querySelectorAll('input[name="basemap"]');
      basemapRadios.forEach(r => r.addEventListener('change', (e) => {
        const val = e.target.value;
        if (val === 'street') {
          map.setLayoutProperty('basemap-street', 'visibility', 'visible');
          map.setLayoutProperty('basemap-satellite', 'visibility', 'none');
        } else if (val === 'satellite') {
          map.setLayoutProperty('basemap-street', 'visibility', 'none');
          map.setLayoutProperty('basemap-satellite', 'visibility', 'visible');
        }
      }));

      // 2D / 3D toggle: wire the checkbox placed in the Base Maps header
          const toggle3d = document.getElementById('toggle-3d');
      if (toggle3d) {
        // New switch markup: rely on CSS for visual state (checked + sibling .switch-track).
        // Ensure the checkbox reflects the initial terrain state and keep JS only for behavior.
        try { toggle3d.checked = true; } catch (e) {}

        toggle3d.addEventListener('change', function() {
          if (this.checked) {
            try { 
              // Only set terrain if DEM source exists
              if (map.getSource('dem')) {
                map.setTerrain({ source: 'dem', exaggeration: 1.2 }); 
              }
            } catch (e) {
              console.debug('Terrain toggle on failed:', e);
            }
            map.easeTo({ pitch: 45, duration: 600 });
          } else {
            try { map.setTerrain(null); } catch (e) {}
            map.easeTo({ pitch: 0, duration: 600 });
          }
        });
      }

    }); 



      // Function to build popup HTML content
      function buildPopupHTML(properties) {
        // Determine the title: prefer name, fall back to type, or use "Feature"
        const title = properties.name || properties.NAME || properties.type || properties.TYPE || "Feature";

        // List of fields to exclude from the popup (unimportant data)
        const excludeFields = new Set([
          "name", "NAME", "type", "TYPE",
          "id", "ID", "geometry", "GEOMETRY",
          "osm_id", "osm_type", "OSM_ID", "OSM_TYPE",
          "@id", "@type",
          "changeset", "timestamp", "user", "uid", "version",
          "visible", "way_id", "node_id", "relation_id",
          "addr:postcode", "fixme"
        ]);

        // Create table rows for properties, filtering out excluded fields
        const rows = Object.entries(properties)
        .filter(([key]) => key.toLowerCase() !== "name")
        .map(
          ([key, value], i) => `
              <tr class="${i % 2 ? 'bg-rose-50' : 'bg-white'}">
              <td class="px-2 py-1 text-slate-800 text-xxs text-gray-600"><strong>${key}</strong></td>
              <td class="px-2 py-1 text-xxs text-gray-600">${value}</td>
            </tr>
          `
        )
        .join("");


        return `
              <div class="max-w-xs font-sans">
            ${name ? `<h3 class="m-0 mb-2 text-base font-bold border-b border-gray-300 p-2 bg-amber-100 text-slate-800">${name}</h3>` : ""}

            ${rows ? `
            <div class="max-h-40 overflow-y-auto border border-gray-300 rounded">
              <table class="w-full border-collapse text-xs">
                <tbody>
                  ${rows}
                </tbody>
              </table>
            </div>` : `<div style="padding:8px; color:#666; font-size:13px;">No additional data</div>`}
          </div>
        `;
    }

    // Add click events for layers to show popups
    const layersWithPopups = [
      'glacier-points-layer',
      'peaks-layer',
      'settlements-layer',
      'airports-layer',
      'rivers-layer',
      'roads-layer',
      'glaciers-outline',
      'glacial-lakes-outline',
      'protected-areas-outline'
    ];

    layersWithPopups.forEach(layerId => {
      map.on("click", layerId, (e) => {
        const props = e.features[0].properties;
        new maplibregl.Popup({ closeButton: true })
          .setLngLat(e.lngLat)
          .setHTML(buildPopupHTML(props))
          .addTo(map);
      });
    });

    // Handle clicks for all layers with layer selection if multiple layers at click point
    // Exclude Salzburg boundary layers from interactive queries so the transparent interior
    // does not appear in popups or the layer dropdown.
    const allInteractiveLayers = [
      'glacier-points-layer',
      'peaks-layer',
      'settlements-layer',
      'airports-layer',
      'rivers-layer',
      'roads-layer',
      'glaciers-fill',
      'glaciers-outline',
      'glacial-lakes-fill',
      'glacial-lakes-outline',
      'protected-areas-fill',
      'protected-areas-outline'
    ];

    map.on("click", (e) => {
      const features = map.queryRenderedFeatures(e.point, {
        layers: allInteractiveLayers
      });

      if (features.length > 0) {
        // Get unique layers at this point
        const uniqueLayers = [...new Set(features.map(f => f.layer.id))];
        
        // Find the top layer (first in the list)
        const topLayerId = uniqueLayers[0];
        const topFeature = features.find(f => f.layer.id === topLayerId);
        
        // Only show popup if top layer is not a municipality boundary (we keep boundaries non-interactive)
        if (topLayerId !== "municipalities-outline") {
          let popupHTML = buildPopupHTML(topFeature.properties);
          
          // Add dropdown if multiple layers
          if (uniqueLayers.length > 1) {
            const dropdownOptions = uniqueLayers.map((layerId, idx) => `
              <option value="${idx}" ${idx === 0 ? 'selected' : ''}>
                ${layerId.replace('-layer', '').replace('-outline', ' outline')}
              </option>
            `).join('');
            
            popupHTML += `
              <div class="mt-2 pt-2 border-t border-gray-300">
                <label class="text-xs block mb-1"><strong>Other layers:</strong></label>
                <select class="layer-dropdown w-full p-1.5 border border-gray-300 rounded text-xs">
                  ${dropdownOptions}
                </select>
              </div>
            `;
          }
          
          const popup = new maplibregl.Popup({ closeButton: true })
            .setLngLat(e.lngLat)
            .setHTML(popupHTML)
            .addTo(map);
          
          // Add dropdown change handler if multiple layers
          if (uniqueLayers.length > 1) {
            setTimeout(() => {
              const dropdown = document.querySelector('.layer-dropdown');
              if (dropdown) {
                dropdown.addEventListener('change', (evt) => {
                  const selectedIdx = parseInt(evt.target.value);
                  const selectedLayerId = uniqueLayers[selectedIdx];
                  const selectedFeature = features.find(f => f.layer.id === selectedLayerId);
                  
                  if (selectedFeature && selectedLayerId !== "municipalities-outline") {
                    popup.remove();
                    let newPopupHTML = buildPopupHTML(selectedFeature.properties);
                    
                    // Re-add dropdown with updated selection
                    const dropdownOptions = uniqueLayers.map((layerId, idx) => `
                      <option value="${idx}" ${idx === selectedIdx ? 'selected' : ''}>
                        ${layerId.replace('-layer', '').replace('-outline', ' outline')}
                      </option>
                    `).join('');
                    
                    newPopupHTML += `
                      <div class="mt-2 pt-2 border-t border-gray-300">
                        <label class="text-xs block mb-1"><strong>Other layers:</strong></label>
                        <select class="layer-dropdown w-full p-1.5 border border-gray-300 rounded text-xs">
                          ${dropdownOptions}
                        </select>
                      </div>
                    `;
                    
                    const newPopup = new maplibregl.Popup({ closeButton: true })
                      .setLngLat(e.lngLat)
                      .setHTML(newPopupHTML)
                      .addTo(map);
                    
                    setTimeout(() => {
                      const newDropdown = document.querySelector('.layer-dropdown');
                      if (newDropdown) {
                        newDropdown.addEventListener('change', arguments.callee);
                      }
                    }, 0);
                  }
                });
              }
            }, 0);
          }
        }
      }
    });


    //--------------------------------mouseover effect------------------------------------  //
    // Hover effects removed - old regions-fill layer no longer exists



    //--------------------------------cursor pointer on layers during hover------------------------------------  //
    // Change cursor to pointer when hovering over interactive layers
    map.on("mousemove", (e) => {
      const features = map.queryRenderedFeatures(e.point, {
        layers: ['glacier-points-layer','peaks-layer','settlements-layer','airports-layer','rivers-layer','roads-layer','glaciers-fill','glaciers-outline','glacial-lakes-fill','glacial-lakes-outline','protected-areas-fill','protected-areas-outline']
      });

      if (features.length) {
        map.getCanvas().classList.add('cursor-pointer');
      } else {
        map.getCanvas().classList.remove('cursor-pointer','cursor-crosshair');
      }
    });

    // Setup marker cursors after map load
    map.on("load", () => {



      // Add scale control (like Google Maps)
      const scale = new maplibregl.ScaleControl({
        maxWidth: 140,
        unit: "metric" // use 'imperial' for miles, 'nautical' for nautical miles
      });
      map.addControl(scale, "bottom-right");
      // Move the scalebar to a fixed bottom-center position so it's centered
      // on the viewport instead of the default bottom-right control group.
      setTimeout(() => {
        try {
          const scaleEl = document.querySelector('.maplibregl-ctrl.maplibregl-ctrl-scale');
          if (scaleEl) {
            // re-parent to document.body and fix position centered at bottom
            document.body.appendChild(scaleEl);
            scaleEl.style.position = 'fixed';
            scaleEl.style.left = '50%';
            scaleEl.style.transform = 'translateX(-50%)';
            scaleEl.style.bottom = '1rem';
            scaleEl.style.zIndex = '65';
          }
        } catch (e) {}
      }, 50);
    });

    // ---------------------- Glacier navigation ----------------------
    // Define glacier locations in WGS84 (EPSG:4326) converted from glacier_points.geojson (EPSG:32645)
    const glacierLocations = {
      thulagi: { name: 'Thulagi Glacial Lake', lat: 28.4707324, lng: 84.511882 },
      lumding: { name: 'Lumding Tsho Glacial Lake', lat: 27.786883, lng: 86.626030 },
      hongu: { name: 'Hongu 2 Glacial Lake', lat: 27.790722, lng: 86.974185 },
      barun: { name: 'Lower Barun Glacial Lake', lat: 27.809898, lng: 87.097743 }
    };

    const glacierButtons = {
      thulagi: document.getElementById('glacier-thulagi'),
      lumding: document.getElementById('glacier-lumding'),
      hongu: document.getElementById('glacier-hongu'),
      barun: document.getElementById('glacier-barun')
    };

    function flyToGlacier(glacierKey) {
      const location = glacierLocations[glacierKey];
      if (!location) return;
      
      // Fly to the glacier location
      map.flyTo({
        center: [location.lng, location.lat],
        zoom: 12,
        duration: 1500
      });

      // Update active button styling
      Object.keys(glacierButtons).forEach(key => {
        const btn = glacierButtons[key];
        if (btn) {
          btn.classList.remove('btn-primary');
          btn.classList.add('btn-secondary');
        }
      });
      
      const activeBtn = glacierButtons[glacierKey];
      if (activeBtn) {
        activeBtn.classList.remove('btn-secondary');
        activeBtn.classList.add('btn-primary');
      }
    }

    // Wire up glacier button click handlers
    Object.keys(glacierButtons).forEach(key => {
      const btn = glacierButtons[key];
      if (btn) {
        btn.addEventListener('click', () => {
          if (map.isMoving()) {
            console.debug('Map is moving, skipping glacier navigation');
            return;
          }
          flyToGlacier(key);
        });
      }
    });

    // Default to Thulagi on page load - wait until map is fully loaded
    map.once('load', () => {
      setTimeout(() => {
        try {
          flyToGlacier('thulagi');
        } catch (e) {
          console.warn('Failed to fly to default glacier location:', e);
        }
      }, 800);
    });
    // Export / Locate / Zoom functions (used by map controls)
    function exportMapPNG() {
      // kept for backwards compatibility
      exportMap('png');
    }

    // Unified export function supporting png, jpeg and pdf
    async function exportMap(format = 'png') {
      try {
        // Wait for map to be fully rendered
        await new Promise(resolve => setTimeout(resolve, 1500));

        // Get the actual WebGL canvas from MapLibre
        const mapCanvas = map.getCanvas();
        if (!mapCanvas) throw new Error('Map canvas not available');

        // Create a new canvas and copy the map canvas content
        const exportCanvas = document.createElement('canvas');
        exportCanvas.width = mapCanvas.width;
        exportCanvas.height = mapCanvas.height;
        const ctx = exportCanvas.getContext('2d');
        
        // Copy the WebGL canvas to the 2D canvas
        ctx.drawImage(mapCanvas, 0, 0);

        if (format === 'pdf') {
          const dataUrl = exportCanvas.toDataURL('image/png');
          const jsPDFClass = (window.jspdf && window.jspdf.jsPDF) ? window.jspdf.jsPDF : (window.jsPDF ? window.jsPDF : null);
          if (!jsPDFClass) { alert('PDF export requires jsPDF. Please check your internet connection.'); return; }
          const img = new Image();
          img.src = dataUrl;
          img.onload = () => {
            const imgW = img.width; const imgH = img.height; const imgRatio = imgW / imgH;
            const pdf = new jsPDFClass({ unit: 'pt', format: 'a4' });
            const pageW = pdf.internal.pageSize.getWidth(); const pageH = pdf.internal.pageSize.getHeight();
            let renderW = pageW; let renderH = pageW / imgRatio;
            if (renderH > pageH) { renderH = pageH; renderW = pageH * imgRatio; }
            const marginX = (pageW - renderW) / 2; const marginY = (pageH - renderH) / 2;
            pdf.addImage(dataUrl, 'PNG', marginX, marginY, renderW, renderH); pdf.save('map.pdf');
          };
          img.onerror = (e) => { console.error('Image load error for PDF export', e); alert('PDF export failed (image load).'); };
          return;
        }

        const mime = format === 'jpeg' ? 'image/jpeg' : 'image/png';
        const quality = format === 'jpeg' ? 0.92 : undefined;
        if (exportCanvas.toBlob) {
          exportCanvas.toBlob((blob) => {
            if (!blob) throw new Error('Failed to generate image blob');
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url; link.download = `map.${format === 'jpeg' ? 'jpg' : 'png'}`; document.body.appendChild(link); link.click(); link.remove(); setTimeout(() => URL.revokeObjectURL(url), 1000);
          }, mime, quality);
        } else {
          const dataUrl = mime === 'image/png' ? exportCanvas.toDataURL('image/png') : exportCanvas.toDataURL('image/jpeg', quality);
          const link = document.createElement('a'); link.href = dataUrl; link.download = `map.${format === 'jpeg' ? 'jpg' : 'png'}`; document.body.appendChild(link); link.click(); link.remove();
        }
      } catch (err) {
        console.error('Export failed:', err);
        alert('Export failed: ' + err.message);
      }

    }

    // Create a Google-like location marker (SVG teardrop with white center)
    function createLocationMarkerElement() {
      const wrapper = document.createElement('div');
      wrapper.className = 'w-9 h-9 inline-block pointer-events-none';

      // Circular location marker: subtle red glow, white border, red core
      wrapper.innerHTML = `
        <svg width="36" height="36" viewBox="0 0 36 36" xmlns="http://www.w3.org/2000/svg" role="img" aria-hidden="true">
          <!-- white border ring -->
          <circle cx="18" cy="18" r="11" fill="#ffffff" />
          <!-- red inner ring -->
          <circle cx="18" cy="18" r="7.5" fill="#2A77ED" />
          <!-- darker primary core (using primary color for consistency) -->
          <circle cx="18" cy="18" r="3" fill="#2A77ED" />
        </svg>
      `;
      return wrapper;
    }

    // Convert meters to pixels at given latitude & zoom for WebMercator / MapLibre
    function metersToPixelsAtZoom(meters, latitude, zoom) {
      const earthCircumference = 40075016.686; // meters
      const latRad = latitude * Math.PI / 180;
      // formula: metersPerPixel = earthCircumference * cos(lat) / 2^(zoom + 8)
      const metersPerPixel = earthCircumference * Math.cos(latRad) / Math.pow(2, zoom + 8);
      return meters / metersPerPixel;
    }

    async function findMyLocation(triggerButton) {
      if (!('geolocation' in navigator)) {
        alert('Geolocation is not available in this browser.');
        return;
      }

      const btn = triggerButton || null;
      if (btn) {
        btn.disabled = true;
        // preserve the button icon HTML and show a small busy indicator (keep icon visible)
        var originalHTML = btn.innerHTML;
        btn.innerHTML = originalHTML + ' <span aria-hidden="true">⏳</span>';
      }

      navigator.geolocation.getCurrentPosition(
        (pos) => {
          const lng = pos.coords.longitude;
          const lat = pos.coords.latitude;
          const accuracy = pos.coords.accuracy || 0; // meters

          map.flyTo({ center: [lng, lat], zoom: 14, speed: 1.2 });

          // Create or update the SVG marker
          if (locationMarker) {
            locationMarker.setLngLat([lng, lat]);
          } else {
            const el = createLocationMarkerElement();
            locationMarker = new maplibregl.Marker({ element: el, anchor: 'bottom' })
              .setLngLat([lng, lat])
              .addTo(map);
          }

          // Add / update an accuracy circle as a GeoJSON source + circle layer
          const accuracySourceId = 'location-accuracy-src';
          const accuracyLayerId = 'location-accuracy-layer';
          const pointGeoJSON = {
            type: 'Feature',
            geometry: { type: 'Point', coordinates: [lng, lat] },
            properties: { accuracy: accuracy }
          };

          if (!map.getSource(accuracySourceId)) {
            map.addSource(accuracySourceId, { type: 'geojson', data: pointGeoJSON });
            map.addLayer({
              id: accuracyLayerId,
              type: 'circle',
              source: accuracySourceId,
              paint: {
                  // keep a subtle red fill only (remove the outer stroke) and make it small by default
                  'circle-color': '#EDA02A',
                  'circle-opacity': 0.12
                }
            });
          } else {
            map.getSource(accuracySourceId).setData(pointGeoJSON);
          }

          // compute and set radius in pixels for the current zoom
          // reduce the visible accuracy buffer size so the outer buffer is much smaller
          const pix = metersToPixelsAtZoom(accuracy, lat, map.getZoom()) * 0.5;
          if (map.getLayer(accuracyLayerId)) {
            map.setPaintProperty(accuracyLayerId, 'circle-radius', pix);
          }

          // store latest accuracy data for zoom handler
          window._locationAccuracy = { lat, accuracy };

          // ensure we update the pixel radius on zoom changes (one-time hookup)
          if (!map._locationAccuracyHandler) {
            map._locationAccuracyHandler = function () {
              const a = window._locationAccuracy;
              if (!a) return;
              // apply same reduced scale when zooming so buffer remains smaller
              const newPix = metersToPixelsAtZoom(a.accuracy, a.lat, map.getZoom()) * 0.5;
              if (map.getLayer(accuracyLayerId)) {
                map.setPaintProperty(accuracyLayerId, 'circle-radius', newPix);
              }
            };
            map.on('zoom', map._locationAccuracyHandler);
          }

          if (btn) {
            btn.disabled = false;
            btn.innerHTML = originalHTML;
          }
        },
        (err) => {
          console.error('Geolocation error:', err);
          alert('Unable to retrieve your location: ' + (err.message || err.code));
          if (btn) {
            btn.disabled = false;
            btn.innerHTML = originalHTML;
          }
        },
        { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
      );
    }

    async function zoomToExtent() {
      try {
        const url = 'data/municipalities_clipped.geojson';
        const resp = await fetch(url);
        if (!resp.ok) throw new Error('Failed to fetch GeoJSON: ' + resp.status);
        const geojson = await resp.json();

        function updateBBoxFromCoords(coords, bbox) {
          if (typeof coords[0] === 'number' && coords.length >= 2) {
            const lng = coords[0];
            const lat = coords[1];
            if (lng < bbox[0]) bbox[0] = lng;
            if (lat < bbox[1]) bbox[1] = lat;
            if (lng > bbox[2]) bbox[2] = lng;
            if (lat > bbox[3]) bbox[3] = lat;
          } else if (Array.isArray(coords)) {
            coords.forEach(c => updateBBoxFromCoords(c, bbox));
          }
        }

        function bboxOfGeoJSON(gj) {
          const bbox = [Infinity, Infinity, -Infinity, -Infinity];
          if (gj.type === 'FeatureCollection') {
            gj.features.forEach(f => {
              if (f.geometry) updateBBoxFromCoords(f.geometry.coordinates, bbox);
            });
          } else if (gj.type === 'Feature' && gj.geometry) {
            updateBBoxFromCoords(gj.geometry.coordinates, bbox);
          } else if (gj.type === 'GeometryCollection' && gj.geometries) {
            gj.geometries.forEach(g => updateBBoxFromCoords(g.coordinates, bbox));
          } else if (gj.coordinates) {
            updateBBoxFromCoords(gj.coordinates, bbox);
          }
          if (bbox[0] === Infinity) return null;
          return [[bbox[0], bbox[1]], [bbox[2], bbox[3]]];
        }

        const bounds = bboxOfGeoJSON(geojson);
        if (!bounds) {
          alert('Could not compute bounds for the GeoJSON.');
          return;
        }

        map.fitBounds(bounds, { padding: 20, maxZoom: 14, duration: 800 });
      } catch (err) {
        console.error('Zoom to extent failed:', err);
        alert('Zoom to extent failed. Check the console for details.');
      }
    }

    // attach to any existing panel buttons if present (we removed panel buttons by default)
    const exportBtn = document.getElementById('export-map');
    if (exportBtn) exportBtn.addEventListener('click', exportMapPNG);

    const findBtn = document.getElementById('find-location');
    if (findBtn) findBtn.addEventListener('click', () => findMyLocation(findBtn));

    const zoomBtn = document.getElementById('zoom-extent');
    if (zoomBtn) zoomBtn.addEventListener('click', zoomToExtent);

    // Add top-left control with Zoom / Locate / Export buttons
    class MapTopLeftControl {
      onAdd(mapInstance) {
        this._map = mapInstance;
        this._container = document.createElement('div');
        // add Tailwind utility classes for a clean, compact control panel
        this._container.className = 'maplibregl-ctrl maplibregl-ctrl-group map-control-container bg-white/95 p-1 rounded-lg shadow-md flex flex-col gap-2';

        const btnZoom = document.createElement('button');
        btnZoom.type = 'button';
        btnZoom.title = 'Zoom to extent';
        // fit/extent icon (Font Awesome)
        btnZoom.innerHTML = `<i class="fa-solid fa-expand text-gray-500" aria-hidden="true"></i>`;
        btnZoom.className = 'inline-flex items-center justify-center w-8 h-8 rounded-md bg-white text-gray-500 border border-gray-100 shadow-sm hover:opacity-90';
        // accessible label
        const zLabel = document.createElement('span');
        zLabel.className = 'sr-only';
        zLabel.textContent = 'Zoom to extent';
        btnZoom.appendChild(zLabel);
        btnZoom.addEventListener('click', () => zoomToExtent());

        const btnLocate = document.createElement('button');
        btnLocate.type = 'button';
        btnLocate.title = 'Find my location';
        // crosshair / locate icon (Font Awesome)
        btnLocate.innerHTML = `<i class="fa-solid fa-location-dot text-gray-500" aria-hidden="true"></i>`;
        btnLocate.className = 'inline-flex items-center justify-center w-8 h-8 rounded-md bg-white text-gray-500 border border-gray-100 shadow-sm hover:opacity-90';
        const lLabel = document.createElement('span');
        lLabel.className = 'sr-only';
        
        btnLocate.appendChild(lLabel);
        btnLocate.addEventListener('click', () => findMyLocation(btnLocate));

        const btnExport = document.createElement('button');
        btnExport.type = 'button';
        btnExport.title = 'Export map';
        // download arrow icon (Font Awesome)
        btnExport.innerHTML = `<i class="fa-solid fa-download text-gray-500" aria-hidden="true"></i>`;
        btnExport.className = 'inline-flex items-center justify-center w-8 h-8 rounded-md bg-white text-gray-500 border border-gray-100 shadow-sm hover:opacity-90';
        const eLabel = document.createElement('span');
        eLabel.className = 'sr-only';
        eLabel.textContent = 'Export map';
        btnExport.appendChild(eLabel);

        // create export menu (PNG / JPEG / PDF)
        const exportMenu = document.createElement('div');
        // hidden by default; toggle visibility when export button is clicked
        exportMenu.className = 'absolute left-0 top-full mt-2 bg-white border border-gray-100 rounded-md p-1 shadow-lg w-40 z-10 hidden';

        const btnPng = document.createElement('button');
        btnPng.type = 'button';
        btnPng.textContent = 'Download PNG';
        btnPng.className = 'w-full text-left px-3 py-2 text-xs bg-transparent text-slate-700 border border-transparent hover:bg-accent/10 rounded-md';
        btnPng.addEventListener('click', (e) => {
          e.stopPropagation();
          exportMap('png');
          exportMenu.classList.remove('show');
        });

        const btnJpeg = document.createElement('button');
        btnJpeg.type = 'button';
        btnJpeg.textContent = 'Download JPEG';
        btnJpeg.className = 'w-full text-left px-3 py-2 text-xs bg-transparent text-slate-700 border border-transparent hover:bg-accent/10 rounded-md';
        btnJpeg.addEventListener('click', (e) => {
          e.stopPropagation();
          exportMap('jpeg');
          exportMenu.classList.remove('show');
        });

        const btnPdf = document.createElement('button');
        btnPdf.type = 'button';
        btnPdf.textContent = 'Download PDF';
        btnPdf.className = 'w-full text-left px-3 py-2 text-xs bg-transparent text-slate-700 border border-transparent hover:bg-accent/10 rounded-md';
        btnPdf.addEventListener('click', (e) => {
          e.stopPropagation();
          exportMap('pdf');
          exportMenu.classList.remove('show');
        });

        exportMenu.appendChild(btnPng);
        exportMenu.appendChild(btnJpeg);
        exportMenu.appendChild(btnPdf);

        // toggle menu on export button click
        btnExport.addEventListener('click', (e) => {
          e.stopPropagation();
          exportMenu.classList.toggle('hidden');
        });

        // close export menu when clicking outside
        document.addEventListener('click', (ev) => {
          if (!exportMenu.contains(ev.target) && ev.target !== btnExport) {
            exportMenu.classList.add('hidden');
          }
        });

        // Tooltips accessible
        btnZoom.setAttribute('aria-label', 'Zoom to extent');
        btnLocate.setAttribute('aria-label', 'Find my location');
        btnExport.setAttribute('aria-label', 'Export map (PNG)');

        this._container.appendChild(btnZoom);
        this._container.appendChild(btnLocate);
  this._container.appendChild(btnExport);
  this._container.appendChild(exportMenu);

        return this._container;
      }
      onRemove() {
        this._container.parentNode.removeChild(this._container);
        this._map = undefined;
      }
    }

    // add the control to top-left
    map.addControl(new MapTopLeftControl(), 'top-left');

    // Legacy panel wiring removed: use centralized `setPanelCollapsed` + `wireMinimizers` above.


      // Simple per-row toggle: click row or chevron toggles only that menu
      (function wireLayerRowClicks() {
        const rows = Array.from(document.querySelectorAll('#layer-panel .layer-row'));

        function setExpanded(btn, open) {
          if (!btn) return;
          btn.setAttribute('aria-expanded', open ? 'true' : 'false');
          const icon = btn.querySelector('i');
          if (icon) {
            icon.classList.remove('fa-ellipsis-vertical', 'fa-chevron-down', 'fa-chevron-up');
            icon.classList.add(open ? 'fa-chevron-up' : 'fa-chevron-down');
          }
        }

        function toggleMenu(menu, btn, open) {
          if (!menu) return;
          const openClasses = ['max-h-80','opacity-100','translate-y-0','pointer-events-auto','p-2'];
          const closedClasses = ['max-h-0','opacity-0','-translate-y-1','pointer-events-none','p-0'];
          if (open) {
            // remove closed state, force reflow, add open state
            menu.classList.remove(...closedClasses);
            // force reflow
            // eslint-disable-next-line no-unused-expressions
            menu.offsetHeight;
            menu.classList.add(...openClasses);
            // Fallback: also set inline styles so the menu becomes visible even if classes are overridden
            try {
              menu.style.opacity = '1';
              menu.style.maxHeight = '20rem';
              menu.style.transform = 'translateY(0)';
              menu.style.pointerEvents = 'auto';
              menu.style.padding = '0.5rem';
            } catch (e) {}
            setExpanded(btn, true);
          } else {
            menu.classList.remove(...openClasses);
            menu.classList.add(...closedClasses);
            // Fallback: reset inline styles to hide
            try {
              menu.style.opacity = '0';
              menu.style.maxHeight = '0';
              menu.style.transform = 'translateY(-0.25rem)';
              menu.style.pointerEvents = 'none';
              menu.style.padding = '0';
            } catch (e) {}
            setExpanded(btn, false);
          }
        }

        rows.forEach(row => {
          const menu = row.nextElementSibling;
          if (!menu || !menu.classList.contains('layer-menu')) return;

          const btn = row.querySelector('.layer-menu-btn');
          setExpanded(btn, false);

          if (btn) {
            btn.addEventListener('click', (e) => {
              e.stopPropagation();
              // Use the button's aria-expanded state as the single source of truth
              // for whether the menu is currently open. This avoids relying on
              // CSS classes that might be overridden elsewhere.
              const isOpen = btn.getAttribute('aria-expanded') === 'true';
              toggleMenu(menu, btn, !isOpen);
            });
          }

          row.addEventListener('click', (ev) => {
              // prevent the document-level click handler from immediately closing menus
              ev.stopPropagation();
              // ignore clicks on interactive controls and the chevron button itself
              if (ev.target.closest('input, select, button') && !ev.target.closest('button.layer-menu-btn')) return;
            // Prefer the aria-expanded attribute (kept in sync by setExpanded)
            const isOpen = btn && btn.getAttribute('aria-expanded') === 'true';
            toggleMenu(menu, btn, !isOpen);
          });

          // keep display state in sync after transition
          menu.addEventListener('transitionend', (ev) => {
            if (ev.target !== menu) return;
            // visual state controlled via 'open' and 'menu-hidden' classes; no inline display tweaks
          });
        });
      })();

    // --- Layer switcher wiring: visibility, labels (off by default), opacity ---
    // Runs once the map is idle so all sources/layers are available.
    map.once('idle', () => {
      const configs = [
        { layers: [{ id: 'glaciers-fill', paintKey: 'fill-opacity' }, { id: 'glaciers-outline', paintKey: 'line-opacity' }], source: 'glaciers', ui: 'glaciers', defaultOpacity: 0.25, labelProperty: 'Id' },
        { layers: [{ id: 'glacial-lakes-fill', paintKey: 'fill-opacity' }, { id: 'glacial-lakes-outline', paintKey: 'line-opacity' }], source: 'glacial-lakes', ui: 'glacial-lakes', defaultOpacity: 0.35, labelProperty: 'Id' },
        { layers: [{ id: 'protected-areas-fill', paintKey: 'fill-opacity' }, { id: 'protected-areas-outline', paintKey: 'line-opacity' }], source: 'protected-areas', ui: 'protected-areas', defaultOpacity: 0.14, labelProperty: 'DAN' },
        { layers: [{ id: 'municipalities-fill', paintKey: 'fill-opacity' }, { id: 'municipalities-outline', paintKey: 'line-opacity' }], source: 'municipalities', ui: 'municipalities', defaultOpacity: 0.06, labelProperty: 'LU_Name' },
        { layers: [{ id: 'rivers-layer', paintKey: 'line-opacity' }], source: 'rivers', ui: 'rivers', defaultOpacity: 1, labelProperty: 'RIV_NAME' },
        { layers: [{ id: 'roads-layer', paintKey: 'line-opacity' }], source: 'roads', ui: 'roads', defaultOpacity: 1, labelProperty: 'NAME' },
        { layers: [{ id: 'glacier-points-layer', paintKey: 'circle-opacity' }], source: 'glacier-points', ui: 'glacier-points', defaultOpacity: 0.9, labelProperty: 'Name' },
        { layers: [{ id: 'peaks-layer', paintKey: 'circle-opacity' }], source: 'peaks', ui: 'peaks', defaultOpacity: 0.95, labelProperty: 'LABEL', labelPropertyFallback: 'NAME' },
        { layers: [{ id: 'settlements-layer', paintKey: 'circle-opacity' }], source: 'settlements', ui: 'settlements', defaultOpacity: 0.9, labelProperty: 'Label', labelPropertyFallback: 'VDCNAME' },
        { layers: [{ id: 'airports-layer', paintKey: 'circle-opacity' }], source: 'airports', ui: 'airports', defaultOpacity: 0.95, labelProperty: 'NAME' }
      ];

      function applyLayout(layersDef, visible) {
        try {
          layersDef.forEach(l => {
            const id = (typeof l === 'string') ? l : l.id;
            if (map.getLayer(id)) map.setLayoutProperty(id, 'visibility', visible ? 'visible' : 'none');
          });
        } catch (e) {}
      }

      function applyPaint(layersDef, value) {
        try {
          layersDef.forEach(l => {
            const id = (typeof l === 'string') ? l : l.id;
            const paintKey = (typeof l === 'string') ? null : l.paintKey;
            if (paintKey && map.getLayer(id)) map.setPaintProperty(id, paintKey, Number(value));
          });
        } catch (e) {}
      }

      // Defer creating label symbol layers until user requests them (glyphs may not be present).
      // We provide an on-demand helper that creates a labels layer if possible.
      function ensureLabelLayer(cfg) {
        const labelId = `${cfg.ui}-labels-layer`;
        if (map.getLayer(labelId)) return true; // already exists

        // If style doesn't declare glyphs, we cannot safely add text-field symbol layers.
        const style = map.getStyle && map.getStyle();
        if (!style || !style.glyphs) {
          console.warn('Map style missing `glyphs` property; cannot create labels for', cfg.ui);
          return false;
        }

        if (!map.getSource(cfg.source)) {
          console.warn('Source not available for labels:', cfg.source);
          return false;
        }

        // Require a label property to exist on the feature properties.
        if (!cfg.labelProperty) {
          console.warn('No label property configured for', cfg.ui, '; skipping label layer creation.');
          return false;
        }

        // Build a coalesce expression that uses the configured property and optional fallback.
        const textField = cfg.labelPropertyFallback ? ['coalesce', ['get', cfg.labelProperty], ['get', cfg.labelPropertyFallback], ''] : ['coalesce', ['get', cfg.labelProperty], ''];

        try {
          // detect underlying layer type (if possible) to choose placement
          let layout = {
            'text-field': textField,
            'text-size': 12,
            'visibility': 'none',
            'text-allow-overlap': false,
            'text-variable-anchor': ['top', 'bottom', 'left', 'right']
          };
          try {
            const firstLayer = (cfg.layers && cfg.layers[0]) ? (typeof cfg.layers[0] === 'string' ? cfg.layers[0] : cfg.layers[0].id) : null;
            if (firstLayer && map.getLayer(firstLayer)) {
              const ltype = map.getLayer(firstLayer).type;
              if (ltype === 'line') {
                // place labels along the line and follow curvature
                layout = {
                  'text-field': textField,
                  'text-size': 12,
                  'visibility': 'none',
                  'symbol-placement': 'line',
                  'text-rotation-alignment': 'map',
                  'text-pitch-alignment': 'map',
                  'text-keep-upright': true,
                  // allow some curvature before breaking the line into segments
                  'text-max-angle': 45,
                  'text-allow-overlap': false
                };
              }
            }
          } catch (e) {}

          map.addLayer({
            id: labelId,
            type: 'symbol',
            source: cfg.source,
            layout: layout,
            paint: {
              'text-color': '#17202A',
              'text-halo-color': '#ffffff',
              // use a slightly larger halo and zero blur for a crisp halo over imagery
              'text-halo-width': 2,
              'text-halo-blur': 0,
              'text-opacity': 1
            }
          });
          return true;
        } catch (e) {
          console.warn('Could not add label layer', labelId, e);
          return false;
        }
      }

        // DOM-based label fallback when style glyphs are not available.
        window._domLabelLayers = window._domLabelLayers || {};
        function createDomLabelLayer(cfg) {
          const id = cfg.ui;
          if (window._domLabelLayers[id]) return true; // already created
          const src = map.getSource(cfg.source);
          if (!src) return false;
          // try to access loaded data; maplibre stores it as _data on the source object
          const data = src._data || (typeof src.getData === 'function' ? src.getData() : null);
          if (!data || !data.features) return false;

          const container = map.getContainer();
          const wrapper = document.createElement('div');
          wrapper.className = 'map-dom-labels';
          wrapper.style.position = 'absolute';
          wrapper.style.top = '0';
          wrapper.style.left = '0';
          wrapper.style.width = '100%';
          wrapper.style.height = '100%';
          wrapper.style.pointerEvents = 'none';
          // Keep DOM labels above the map canvas but below UI panels (UI uses z-20).
          wrapper.style.zIndex = '0';
          container.appendChild(wrapper);

          const items = [];

          function makeLabel(feature) {
            const props = feature.properties || {};
            let txt = props[cfg.labelProperty] || (cfg.labelPropertyFallback && props[cfg.labelPropertyFallback]) || '';
            if (!txt) return null;
            let coord = null;
            try {
              if (feature.geometry && feature.geometry.type === 'Point') coord = feature.geometry.coordinates;
              else coord = turf.centroid(feature).geometry.coordinates;
            } catch (e) { return null; }

            // Create a blurred white shadow element behind the label (cross-browser halo)
            const shadow = document.createElement('div');
            shadow.className = 'map-dom-label-shadow';
            shadow.textContent = String(txt);
            shadow.style.position = 'absolute';
            // Position the shadow exactly like the label but scale it slightly larger
            shadow.style.transform = 'translate(-50%,-100%) scale(1.12)';
            shadow.style.transformOrigin = '50% 100%';
            shadow.style.whiteSpace = 'nowrap';
            shadow.style.fontSize = '12px';
            shadow.style.color = '#ffffff';
            // shadow.style.filter = 'blur(2px)';
            shadow.style.opacity = '1';
            shadow.style.pointerEvents = 'none';
            shadow.style.zIndex = '0';
            wrapper.appendChild(shadow);

            const el = document.createElement('div');
            el.className = 'map-dom-label';
            el.textContent = String(txt);
            el.style.position = 'absolute';
            el.style.transform = 'translate(-50%,-100%)';
            el.style.transformOrigin = '50% 100%';
            el.style.whiteSpace = 'nowrap';
            el.style.fontSize = '12px';
            el.style.color = '#17202A';
            el.style.fontWeight = '600';
            el.style.opacity = '1';
            el.style.pointerEvents = 'none';
            el.style.zIndex = '1';
            wrapper.appendChild(el);
            // make the shadow visually thicker
            shadow.style.fontWeight = '700';
            items.push({ el, shadow, coord });
            return el;
          }

          data.features.forEach(f => makeLabel(f));

          const updatePositions = function() {
            try {
              items.forEach(item => {
                const p = map.project(item.coord);
                if (item.shadow) {
                  item.shadow.style.left = p.x + 'px';
                  item.shadow.style.top = p.y + 'px';
                }
                if (item.el) {
                  item.el.style.left = p.x + 'px';
                  item.el.style.top = p.y + 'px';
                }
              });
            } catch (e) {}
          };

          // initial placement and bind handlers
          updatePositions();
          map.on('move', updatePositions);
          map.on('zoom', updatePositions);
          map.on('resize', updatePositions);

          window._domLabelLayers[id] = { wrapper, items, updatePositions };
          return true;
        }

        function removeDomLabelLayer(cfg) {
          const id = cfg.ui;
          const rec = window._domLabelLayers && window._domLabelLayers[id];
          if (!rec) return;
          try { map.off('move', rec.updatePositions); map.off('zoom', rec.updatePositions); map.off('resize', rec.updatePositions); } catch(e) {}
          try { rec.wrapper.remove(); } catch (e) {}
          delete window._domLabelLayers[id];
        }

      // Hook up UI controls
      configs.forEach(cfg => {
        const uiBase = cfg.ui;
        const visibleEl = document.getElementById(`layer-${uiBase}-visible`);
        const labelsEl = document.getElementById(`layer-${uiBase}-labels`);
        const opacityEl = document.getElementById(`layer-${uiBase}-opacity`);
        const labelLayerId = `${uiBase}-labels-layer`;
        const layersDef = cfg.layers || [];

        if (visibleEl) {
          try {
            const firstLayerId = layersDef[0] && layersDef[0].id;
            const vis = firstLayerId ? map.getLayoutProperty(firstLayerId, 'visibility') : 'visible';
            visibleEl.checked = (vis !== 'none');
          } catch (e) { visibleEl.checked = true; }
          visibleEl.addEventListener('change', (ev) => {
            applyLayout(layersDef, ev.target.checked);
            if (!ev.target.checked && labelsEl && labelsEl.checked) {
              labelsEl.checked = false;
              applyLayout([labelLayerId], false);
            }
            // When visibility changes, update legend rows and rebuild legend
            const legendRows = document.querySelectorAll(`[data-legend-layer="${cfg.ui}"]`);
            legendRows.forEach(row => {
              row.style.display = ev.target.checked ? 'flex' : 'none';
            });
            // Also rebuild legend to ensure consistency
            try { if (typeof createLegendFromLayers === 'function') createLegendFromLayers(); } catch (e) {}
          });
        }

        if (opacityEl) {
          opacityEl.value = cfg.defaultOpacity !== undefined ? cfg.defaultOpacity : 1;
          opacityEl.addEventListener('input', (ev) => {
            applyPaint(layersDef, Number(ev.target.value));
            try { if (typeof createLegendFromLayers === 'function') createLegendFromLayers(); } catch (e) {}
          });
          try {
            const first = layersDef[0];
            const p = first && map.getPaintProperty(first.id, first.paintKey);
            if (p !== undefined && p !== null) opacityEl.value = p;
          } catch (e) {}
        }

        if (labelsEl) {
          // Enable labels by default only for glacier points; others remain off
          labelsEl.checked = (cfg.ui === 'glacier-points');

          // If a source was already loaded, try to auto-detect a good label property.
          const loaded = window._loadedSources && window._loadedSources[cfg.source];
          if (!cfg.labelProperty && loaded && loaded.features && loaded.features.length) {
            const sample = loaded.features.find(f => f && f.properties && Object.keys(f.properties).length);
            if (sample) {
              const keys = Object.keys(sample.properties).map(k => k.trim());
              const prefer = ['LABEL','Label','name','Name','NAME','RIV_NAME','DAN','Id','LU_Name','VDCNAME'];
              const pick = prefer.find(p => keys.includes(p));
              if (pick) {
                cfg.labelProperty = pick;
              } else if (keys.length) {
                cfg.labelProperty = keys[0];
              }
            }
          }

          // If still no labelProperty, disable the checkbox until one is available.
          if (!cfg.labelProperty) {
            labelsEl.disabled = true;
            labelsEl.title = 'No label attribute available for this dataset.';
            labelsEl.checked = false;
            console.info('Labels disabled for', cfg.ui, '- no labelProperty configured');
            return;
          } else {
            labelsEl.disabled = false;
            labelsEl.title = `Labels: ${cfg.labelProperty}`;

            // If this checkbox is pre-checked (glacier points), attempt to create labels now.
            if (labelsEl.checked) {
              const labelLayerId = `${cfg.ui}-labels-layer`;
              const symOk = ensureLabelLayer(cfg);
              if (symOk && map.getLayer(labelLayerId)) {
                try { map.setLayoutProperty(labelLayerId, 'visibility', 'visible'); } catch (e) {}
                try { removeDomLabelLayer(cfg); } catch (e) {}
              } else {
                const ok = createDomLabelLayer(cfg);
                if (!ok) {
                  labelsEl.checked = false;
                  labelsEl.disabled = true;
                  labelsEl.title = 'Could not create labels: source may not be loaded yet.';
                  console.warn('Initial label creation failed for', cfg.ui);
                }
              }
            }
          }

          // Try to create a MapLibre symbol label layer first. If that fails (no glyphs
          // or source not yet loaded), fall back to the DOM label renderer.
          labelsEl.addEventListener('change', (ev) => {
            const enable = ev.target.checked;
            const labelLayerId = `${cfg.ui}-labels-layer`;
            if (enable) {
              // Try symbol layer creation / visibility
              const symOk = ensureLabelLayer(cfg);
              if (symOk && map.getLayer(labelLayerId)) {
                try { map.setLayoutProperty(labelLayerId, 'visibility', 'visible'); } catch (e) {}
                // remove any existing DOM labels if present
                try { removeDomLabelLayer(cfg); } catch (e) {}
                return;
              }

              // Fallback to DOM labels when symbol layer cannot be created yet
              const ok = createDomLabelLayer(cfg);
              if (!ok) {
                ev.target.checked = false;
                ev.target.disabled = true;
                ev.target.title = 'Could not create labels: source may not be loaded yet.';
                console.warn('Label creation failed for', cfg.ui);
              }
            } else {
              // hide symbol labels if present
              try { if (map.getLayer(labelLayerId)) map.setLayoutProperty(labelLayerId, 'visibility', 'none'); } catch (e) {}
              // remove DOM labels if present
              try { removeDomLabelLayer(cfg); } catch (e) {}
            }
          });
        }
      });

      // Build a legend from the actual layer paint properties so swatches match the map
      function createLegendFromLayers() {
        const items = [
          { label: 'Glaciers (polygons)', layerId: 'glaciers-fill', type: 'fill', outlineId: 'glaciers-outline', ui: 'glaciers' },
          { label: 'Glacial lakes', layerId: 'glacial-lakes-fill', type: 'fill', outlineId: 'glacial-lakes-outline', ui: 'glacial-lakes' },
          { label: 'Protected areas', layerId: 'protected-areas-fill', type: 'fill', outlineId: 'protected-areas-outline', ui: 'protected-areas' },
          { label: 'Rivers', layerId: 'rivers-layer', type: 'line', ui: 'rivers' },
          { label: 'Roads', layerId: 'roads-layer', type: 'line', ui: 'roads' },
          { label: 'Glacier Points', layerId: 'glacier-points-layer', type: 'circle', ui: 'glacier-points' },
          { label: 'Settlements', layerId: 'settlements-layer', type: 'circle', ui: 'settlements' },
          { label: 'Peaks', layerId: 'peaks-layer', type: 'circle', ui: 'peaks' },
          { label: 'Airports', layerId: 'airports-layer', type: 'circle', ui: 'airports' },
          { label: 'Municipalities', layerId: 'municipalities-fill', type: 'fill', outlineId: 'municipalities-outline', ui: 'municipalities' }
        ];

        const body = document.querySelector('#map-legend .panel-body');
        if (!body) return;
        body.innerHTML = '';

        function paintVal(layerId, prop) {
          try {
            const v = map.getPaintProperty(layerId, prop);
            if (typeof v === 'string') return v;
            if (typeof v === 'number') return v;
            if (Array.isArray(v)) return v.join(',');
          } catch (e) {}
          return null;
        }

        function colorToRgba(color, opacity) {
          if (!color) return null;
          // if already rgba(...)
          if (color.startsWith('rgba')) {
            return color;
          }
          if (color.startsWith('rgb(')) {
            // inject opacity
            const inner = color.slice(4, -1);
            return `rgba(${inner}, ${opacity !== undefined && opacity !== null ? opacity : 1})`;
          }
          // hex formats
          if (color[0] === '#') {
            let hex = color.slice(1);
            if (hex.length === 3) {
              hex = hex.split('').map(c => c + c).join('');
            }
            const int = parseInt(hex, 16);
            const r = (int >> 16) & 255;
            const g = (int >> 8) & 255;
            const b = int & 255;
            const a = (opacity !== undefined && opacity !== null) ? opacity : 1;
            return `rgba(${r}, ${g}, ${b}, ${a})`;
          }
          // fallback: return original
          return color;
        }

        items.forEach(it => {
          const row = document.createElement('div');
          row.className = 'flex items-center gap-3';

          // create an inline SVG swatch for reliable stroke/fill/width rendering
          const svgNS = 'http://www.w3.org/2000/svg';
          const svg = document.createElementNS(svgNS, 'svg');
          svg.setAttribute('width', '36');
          svg.setAttribute('height', '18');
          svg.setAttribute('viewBox', '0 0 36 18');
          svg.style.display = 'block';

          try {
            if (it.type === 'fill') {
              const fillColor = paintVal(it.layerId, 'fill-color') || '#999';
              const fillOp = paintVal(it.layerId, 'fill-opacity');
              const rect = document.createElementNS(svgNS, 'rect');
              rect.setAttribute('x', '2'); rect.setAttribute('y', '2'); rect.setAttribute('width', '32'); rect.setAttribute('height', '14'); rect.setAttribute('rx', '3');
              rect.setAttribute('fill', colorToRgba(String(fillColor), fillOp));

              // outline stroke
              if (it.outlineId && map.getLayer(it.outlineId)) {
                const lineColor = paintVal(it.outlineId, 'line-color');
                const lineOp = paintVal(it.outlineId, 'line-opacity');
                const lineWidth = paintVal(it.outlineId, 'line-width') || 1;
                const dash = map.getPaintProperty(it.outlineId, 'line-dasharray');
                if (lineColor) {
                  rect.setAttribute('stroke', colorToRgba(String(lineColor), lineOp));
                  rect.setAttribute('stroke-width', String(Math.max(1, Number(lineWidth))));
                  if (Array.isArray(dash) && dash.length) rect.setAttribute('stroke-dasharray', dash.join(' '));
                }
              }
              svg.appendChild(rect);
            } else if (it.type === 'line') {
              const lineColor = paintVal(it.layerId, 'line-color') || '#999';
              const lineWidth = paintVal(it.layerId, 'line-width') || 2;
              const dash = map.getPaintProperty(it.layerId, 'line-dasharray');
              const y = 9;
              const line = document.createElementNS(svgNS, 'line');
              line.setAttribute('x1', '2'); line.setAttribute('y1', String(y)); line.setAttribute('x2', '34'); line.setAttribute('y2', String(y));
              line.setAttribute('stroke', colorToRgba(String(lineColor), paintVal(it.layerId, 'line-opacity')));
              line.setAttribute('stroke-width', String(Math.max(1, Number(lineWidth))));
              line.setAttribute('stroke-linecap', 'round');
              if (Array.isArray(dash) && dash.length) line.setAttribute('stroke-dasharray', dash.join(' '));
              svg.appendChild(line);
            } else if (it.type === 'circle') {
              const c = paintVal(it.layerId, 'circle-color') || '#999';
              const rVal = paintVal(it.layerId, 'circle-radius') || 6;
              const r = Math.max(3, Math.min(8, Number(rVal)));
              const circ = document.createElementNS(svgNS, 'circle');
              circ.setAttribute('cx', '9'); circ.setAttribute('cy', '9'); circ.setAttribute('r', String(r));
              circ.setAttribute('fill', colorToRgba(String(c), paintVal(it.layerId, 'circle-opacity')));
              svg.appendChild(circ);
            }
          } catch (e) {
            // fallback: simple rect
            const rect = document.createElementNS(svgNS, 'rect');
            rect.setAttribute('x', '2'); rect.setAttribute('y', '2'); rect.setAttribute('width', '32'); rect.setAttribute('height', '14'); rect.setAttribute('rx', '3'); rect.setAttribute('fill', '#999');
            svg.appendChild(rect);
          }

          const iconWrap = document.createElement('div');
          iconWrap.style.width = '36px'; iconWrap.style.height = '18px';
          iconWrap.appendChild(svg);

          const label = document.createElement('div');
          label.className = 'flex-1 text-xxs text-gray-600';
          label.textContent = it.label;

          row.appendChild(iconWrap);
          row.appendChild(label);
          
          // Add data attribute for dynamic show/hide and set initial visibility
          if (it.ui) {
            row.setAttribute('data-legend-layer', it.ui);
            try {
              const firstLayerId = it.layerId;
              const vis = map.getLayoutProperty(firstLayerId, 'visibility');
              // layer is hidden if visibility is explicitly set to 'none'
              if (vis === 'none') row.style.display = 'none';
            } catch (e) {
              // if error or layer not found, assume visible
            }
          }
          
          body.appendChild(row);
        });
      }

      // Create legend now (layers exist) and also update on style load if needed
      try { createLegendFromLayers(); } catch (e) { console.warn('Legend creation failed', e); }

      // Wire marker show/hide
      function setMarkerDisplay(markerObj, visible) {
        try {
          const el = markerObj && markerObj.getElement && markerObj.getElement();
          if (el) el.classList.toggle('hidden', !visible);
        } catch (e) {}
      }

      const mDefault = document.getElementById('marker-default-visible');
      const mPng = document.getElementById('marker-png-visible');
      const mHtml = document.getElementById('marker-html-visible');

      if (mDefault) mDefault.addEventListener('change', (e) => { if (typeof markerDefault !== 'undefined') setMarkerDisplay(markerDefault, e.target.checked); });
      if (mPng) mPng.addEventListener('change', (e) => { if (typeof markerPNG !== 'undefined') setMarkerDisplay(markerPNG, e.target.checked); });
      if (mHtml) mHtml.addEventListener('change', (e) => { if (typeof markerHTML !== 'undefined') setMarkerDisplay(markerHTML, e.target.checked); });

    });

    // --- UI enhancement: convert each `.layer-sub` into a three-dot popover menu ---
    (function enhanceLayerUI() {
      const layerGroups = document.querySelectorAll('#layer-panel .layer-group');
      layerGroups.forEach(group => {
        // If the new layout already contains a layer-menu-btn, skip creating one
        if (group.querySelector('.layer-menu-btn')) return;

        const header = group.querySelector('.layer-header');
        const sub = group.querySelector('.layer-sub');
        if (!header || !sub) return;

        // create menu button (three dots) for older layouts only
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'layer-menu-btn btn-tertiary';
        btn.setAttribute('aria-haspopup', 'true');
        btn.setAttribute('aria-expanded', 'false');
        btn.innerHTML = '<span class="sr-only">Open layer options</span>▾';

        // mark sub as popover for older layout compatibility
        sub.classList.add('popover');

        // attach click handler to toggle popover
        btn.addEventListener('click', (ev) => {
          ev.stopPropagation();
          const open = sub.classList.toggle('open');
          btn.setAttribute('aria-expanded', String(open));
          document.querySelectorAll('#layer-panel .layer-sub.popover.open').forEach(o => { if (o !== sub) o.classList.remove('open'); });
        });

        header.appendChild(btn);

        // click outside to close
        document.addEventListener('click', (e) => {
          if (!sub.contains(e.target) && !btn.contains(e.target)) {
            sub.classList.remove('open');
            btn.setAttribute('aria-expanded', 'false');
          }
        });

        
      });
    })();

    // Wire up any .layer-menu-btn created in the new Tailwind layout
    (function wireLayerMenuButtons() {
      // Only wire buttons that belong to the older "layer-sub" layout.
      // Buttons that are inside a `.layer-row` are handled by `wireLayerRowClicks()`
      // and should be skipped to avoid duplicate/conflicting handlers.
      const buttons = Array.from(document.querySelectorAll('#layer-panel .layer-menu-btn')).filter(b => !b.closest('.layer-row'));
      const closedClasses = ['max-h-0','opacity-0','-translate-y-1','pointer-events-none','p-0'];
      const openClasses = ['max-h-80','opacity-100','translate-y-0','pointer-events-auto','p-2'];

      buttons.forEach(btn => {
        btn.addEventListener('click', (ev) => {
          ev.stopPropagation();
          // Prefer the menu as the immediate next sibling (new layout). Fall back to searching inside parent for older layouts.
          const row = btn.parentElement || btn.closest('div');
          let menu = null;
          if (row && row.nextElementSibling && row.nextElementSibling.classList.contains('layer-menu')) {
            menu = row.nextElementSibling;
          } else if (row) {
            menu = row.querySelector('.layer-menu') || row.parentElement && row.parentElement.querySelector('.layer-menu');
          }
          if (!menu) return;

          // Close other menus first so only one is open at a time
          document.querySelectorAll('#layer-panel .layer-menu').forEach(m => { if (m !== menu) { m.classList.remove(...openClasses); m.classList.add(...closedClasses); } });

          // Toggle current menu
          const willShow = menu.classList.contains('pointer-events-none');
          if (willShow) {
            menu.classList.remove(...closedClasses);
            // force reflow
            menu.offsetHeight;
            menu.classList.add(...openClasses);
            btn.setAttribute('aria-expanded', 'true');
          } else {
            menu.classList.remove(...openClasses);
            menu.classList.add(...closedClasses);
            btn.setAttribute('aria-expanded', 'false');
          }
        });
      });

      // close menus on outside click (ignore clicks on menu buttons)
      document.addEventListener('click', (e) => {
        const isBtn = e.target.closest && e.target.closest('.layer-menu-btn');
        if (isBtn) return; // clicks on buttons are handled above

        document.querySelectorAll('#layer-panel .layer-menu').forEach(menu => {
          if (!menu.contains(e.target)) {
            menu.classList.remove(...openClasses);
            menu.classList.add(...closedClasses);
          }
        });
        // Only update aria-expanded for the buttons this helper manages
        buttons.forEach(b => b.setAttribute('aria-expanded', 'false'));
      });

      // close menus on Escape key
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' || e.key === 'Esc') {
          document.querySelectorAll('#layer-panel .layer-menu').forEach(menu => {
            menu.classList.remove(...openClasses);
            menu.classList.add(...closedClasses);
          });
          buttons.forEach(b => b.setAttribute('aria-expanded', 'false'));
        }
      });
    })();





  </script>
  <!-- jsPDF for client-side PDF export -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <!-- html2canvas for full-page screenshot export -->
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <!-- main.js includes the layers and other map logic--> 
  <script src="main.js"></script>
</script>
  <script>
    // Paint range inputs' filled portion using CSS background gradient
    (function paintRangeFills() {
      const FILL = '#9CA3AF'; // bg-gray-400
      const TRACK = '#D6D9DE'; // bg-gray-200

      function update(el) {
        const min = parseFloat(el.min) || 0;
        const max = parseFloat(el.max) || 1;
        const val = parseFloat(el.value);
        const pct = Math.round(((val - min) / (max - min)) * 100);
        el.style.background = `linear-gradient(90deg, ${FILL} ${pct}%, ${TRACK} ${pct}%)`;
      }

      function wire(el) {
        update(el);
        el.addEventListener('input', () => update(el));
        el.addEventListener('change', () => update(el));
      }

      document.querySelectorAll('.layer-menu input[type="range"]').forEach(wire);

      // Observe DOM for dynamically added range inputs inside layer-menu
      const observer = new MutationObserver(muts => {
        muts.forEach(m => {
          m.addedNodes && m.addedNodes.forEach(n => {
            if (!(n instanceof HTMLElement)) return;
            n.querySelectorAll && n.querySelectorAll('.layer-menu input[type="range"]').forEach(wire);
            if (n.matches && n.matches('.layer-menu input[type="range"]')) wire(n);
          });
        });
      });
      observer.observe(document.getElementById('layer-panel') || document.body, { childList: true, subtree: true });
    })();
  </script>
</body>
</html>
